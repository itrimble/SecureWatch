{"version":3,"sources":["../src/lexer/types.ts","../src/lexer/lexer.ts","../src/parser/parser.ts","../src/execution/query-executor.ts","../src/execution/sql-generator.ts","../src/execution/types.ts","../src/execution/query-optimizer.ts","../src/intellisense/types.ts","../src/intellisense/completion-provider.ts","../src/intellisense/schema-provider.ts","../src/kql-engine.ts","../src/templates/security-templates.ts","../src/utils/kql-utils.ts"],"sourcesContent":["export enum TokenType {\n  // Literals\n  STRING = 'STRING',\n  NUMBER = 'NUMBER',\n  BOOLEAN = 'BOOLEAN',\n  DATETIME = 'DATETIME',\n  TIMESPAN = 'TIMESPAN',\n  GUID = 'GUID',\n  \n  // Identifiers\n  IDENTIFIER = 'IDENTIFIER',\n  QUOTED_IDENTIFIER = 'QUOTED_IDENTIFIER',\n  \n  // Operators\n  PIPE = 'PIPE',\n  EQUAL = 'EQUAL',\n  NOT_EQUAL = 'NOT_EQUAL',\n  LESS_THAN = 'LESS_THAN',\n  LESS_EQUAL = 'LESS_EQUAL',\n  GREATER_THAN = 'GREATER_THAN',\n  GREATER_EQUAL = 'GREATER_EQUAL',\n  CONTAINS = 'CONTAINS',\n  NOT_CONTAINS = 'NOT_CONTAINS',\n  STARTSWITH = 'STARTSWITH',\n  ENDSWITH = 'ENDSWITH',\n  MATCHES = 'MATCHES',\n  IN = 'IN',\n  NOT_IN = 'NOT_IN',\n  BETWEEN = 'BETWEEN',\n  LIKE = 'LIKE',\n  \n  // Logical operators\n  AND = 'AND',\n  OR = 'OR',\n  NOT = 'NOT',\n  \n  // Arithmetic operators\n  PLUS = 'PLUS',\n  MINUS = 'MINUS',\n  MULTIPLY = 'MULTIPLY',\n  DIVIDE = 'DIVIDE',\n  MODULO = 'MODULO',\n  \n  // Punctuation\n  COMMA = 'COMMA',\n  SEMICOLON = 'SEMICOLON',\n  DOT = 'DOT',\n  LPAREN = 'LPAREN',\n  RPAREN = 'RPAREN',\n  LBRACKET = 'LBRACKET',\n  RBRACKET = 'RBRACKET',\n  LBRACE = 'LBRACE',\n  RBRACE = 'RBRACE',\n  \n  // Keywords\n  WHERE = 'WHERE',\n  PROJECT = 'PROJECT',\n  EXTEND = 'EXTEND',\n  SUMMARIZE = 'SUMMARIZE',\n  ORDER = 'ORDER',\n  TOP = 'TOP',\n  LIMIT = 'LIMIT',\n  DISTINCT = 'DISTINCT',\n  COUNT = 'COUNT',\n  SUM = 'SUM',\n  AVG = 'AVG',\n  MIN = 'MIN',\n  MAX = 'MAX',\n  BY = 'BY',\n  ASC = 'ASC',\n  DESC = 'DESC',\n  JOIN = 'JOIN',\n  INNER = 'INNER',\n  LEFT = 'LEFT',\n  RIGHT = 'RIGHT',\n  FULL = 'FULL',\n  ON = 'ON',\n  UNION = 'UNION',\n  LET = 'LET',\n  IF = 'IF',\n  CASE = 'CASE',\n  WHEN = 'WHEN',\n  THEN = 'THEN',\n  ELSE = 'ELSE',\n  END = 'END',\n  NULL = 'NULL',\n  TRUE = 'TRUE',\n  FALSE = 'FALSE',\n  \n  // Special\n  EOF = 'EOF',\n  NEWLINE = 'NEWLINE',\n  WHITESPACE = 'WHITESPACE',\n  COMMENT = 'COMMENT',\n  \n  // Error\n  INVALID = 'INVALID'\n}\n\nexport interface Token {\n  type: TokenType;\n  value: string;\n  start: number;\n  end: number;\n  line: number;\n  column: number;\n}\n\nexport interface LexerPosition {\n  index: number;\n  line: number;\n  column: number;\n}\n\nexport interface LexerError {\n  message: string;\n  position: LexerPosition;\n  token?: Token;\n}","import { Token, TokenType, LexerPosition, LexerError } from './types';\n\nexport class KQLLexer {\n  private input: string;\n  private position: LexerPosition;\n  private tokens: Token[] = [];\n  private errors: LexerError[] = [];\n\n  // Keywords mapping\n  private static readonly KEYWORDS: Map<string, TokenType> = new Map([\n    ['where', TokenType.WHERE],\n    ['project', TokenType.PROJECT],\n    ['extend', TokenType.EXTEND],\n    ['summarize', TokenType.SUMMARIZE],\n    ['order', TokenType.ORDER],\n    ['top', TokenType.TOP],\n    ['limit', TokenType.LIMIT],\n    ['distinct', TokenType.DISTINCT],\n    ['count', TokenType.COUNT],\n    ['sum', TokenType.SUM],\n    ['avg', TokenType.AVG],\n    ['min', TokenType.MIN],\n    ['max', TokenType.MAX],\n    ['by', TokenType.BY],\n    ['asc', TokenType.ASC],\n    ['desc', TokenType.DESC],\n    ['join', TokenType.JOIN],\n    ['inner', TokenType.INNER],\n    ['left', TokenType.LEFT],\n    ['right', TokenType.RIGHT],\n    ['full', TokenType.FULL],\n    ['on', TokenType.ON],\n    ['union', TokenType.UNION],\n    ['let', TokenType.LET],\n    ['if', TokenType.IF],\n    ['case', TokenType.CASE],\n    ['when', TokenType.WHEN],\n    ['then', TokenType.THEN],\n    ['else', TokenType.ELSE],\n    ['end', TokenType.END],\n    ['null', TokenType.NULL],\n    ['true', TokenType.TRUE],\n    ['false', TokenType.FALSE],\n    ['and', TokenType.AND],\n    ['or', TokenType.OR],\n    ['not', TokenType.NOT],\n    ['contains', TokenType.CONTAINS],\n    ['startswith', TokenType.STARTSWITH],\n    ['endswith', TokenType.ENDSWITH],\n    ['matches', TokenType.MATCHES],\n    ['in', TokenType.IN],\n    ['between', TokenType.BETWEEN],\n    ['like', TokenType.LIKE]\n  ]);\n\n  // Multi-character operators\n  private static readonly OPERATORS: Map<string, TokenType> = new Map([\n    ['==', TokenType.EQUAL],\n    ['!=', TokenType.NOT_EQUAL],\n    ['<>', TokenType.NOT_EQUAL],\n    ['<=', TokenType.LESS_EQUAL],\n    ['>=', TokenType.GREATER_EQUAL],\n    ['!contains', TokenType.NOT_CONTAINS],\n    ['!in', TokenType.NOT_IN]\n  ]);\n\n  constructor(input: string) {\n    this.input = input;\n    this.position = { index: 0, line: 1, column: 1 };\n  }\n\n  tokenize(): { tokens: Token[], errors: LexerError[] } {\n    this.tokens = [];\n    this.errors = [];\n    this.position = { index: 0, line: 1, column: 1 };\n\n    while (!this.isAtEnd()) {\n      try {\n        this.scanToken();\n      } catch (error) {\n        this.addError(`Unexpected character: ${this.peek()}`, this.position);\n        this.advance();\n      }\n    }\n\n    this.addToken(TokenType.EOF, '');\n    return { tokens: this.tokens, errors: this.errors };\n  }\n\n  private scanToken(): void {\n    const start = this.position;\n    const char = this.advance();\n\n    switch (char) {\n      case ' ':\n      case '\\r':\n      case '\\t':\n        // Skip whitespace\n        break;\n      case '\\n':\n        this.addToken(TokenType.NEWLINE, char);\n        this.position.line++;\n        this.position.column = 1;\n        break;\n      case '|':\n        this.addToken(TokenType.PIPE, char);\n        break;\n      case ',':\n        this.addToken(TokenType.COMMA, char);\n        break;\n      case ';':\n        this.addToken(TokenType.SEMICOLON, char);\n        break;\n      case '.':\n        this.addToken(TokenType.DOT, char);\n        break;\n      case '(':\n        this.addToken(TokenType.LPAREN, char);\n        break;\n      case ')':\n        this.addToken(TokenType.RPAREN, char);\n        break;\n      case '[':\n        this.addToken(TokenType.LBRACKET, char);\n        break;\n      case ']':\n        this.addToken(TokenType.RBRACKET, char);\n        break;\n      case '{':\n        this.addToken(TokenType.LBRACE, char);\n        break;\n      case '}':\n        this.addToken(TokenType.RBRACE, char);\n        break;\n      case '+':\n        this.addToken(TokenType.PLUS, char);\n        break;\n      case '-':\n        this.addToken(TokenType.MINUS, char);\n        break;\n      case '*':\n        this.addToken(TokenType.MULTIPLY, char);\n        break;\n      case '/':\n        if (this.match('/')) {\n          // Single line comment\n          this.scanComment();\n        } else if (this.match('*')) {\n          // Multi-line comment\n          this.scanMultilineComment();\n        } else {\n          this.addToken(TokenType.DIVIDE, char);\n        }\n        break;\n      case '%':\n        this.addToken(TokenType.MODULO, char);\n        break;\n      case '=':\n        if (this.match('=')) {\n          this.addToken(TokenType.EQUAL, '==');\n        } else {\n          this.addError('Unexpected character: =', start);\n        }\n        break;\n      case '!':\n        if (this.match('=')) {\n          this.addToken(TokenType.NOT_EQUAL, '!=');\n        } else if (this.matchWord('contains')) {\n          this.addToken(TokenType.NOT_CONTAINS, '!contains');\n        } else if (this.matchWord('in')) {\n          this.addToken(TokenType.NOT_IN, '!in');\n        } else {\n          this.addError('Unexpected character: !', start);\n        }\n        break;\n      case '<':\n        if (this.match('=')) {\n          this.addToken(TokenType.LESS_EQUAL, '<=');\n        } else if (this.match('>')) {\n          this.addToken(TokenType.NOT_EQUAL, '<>');\n        } else {\n          this.addToken(TokenType.LESS_THAN, char);\n        }\n        break;\n      case '>':\n        if (this.match('=')) {\n          this.addToken(TokenType.GREATER_EQUAL, '>=');\n        } else {\n          this.addToken(TokenType.GREATER_THAN, char);\n        }\n        break;\n      case '\"':\n        this.scanString('\"');\n        break;\n      case \"'\":\n        this.scanString(\"'\");\n        break;\n      case '`':\n        this.scanQuotedIdentifier();\n        break;\n      default:\n        if (this.isDigit(char)) {\n          this.scanNumber();\n        } else if (this.isAlpha(char)) {\n          this.scanIdentifier();\n        } else {\n          this.addError(`Unexpected character: ${char}`, start);\n        }\n        break;\n    }\n  }\n\n  private scanString(quote: string): void {\n    const start = this.position.index - 1;\n    let value = '';\n\n    while (!this.isAtEnd() && this.peek() !== quote) {\n      if (this.peek() === '\\n') {\n        this.position.line++;\n        this.position.column = 1;\n      }\n      \n      if (this.peek() === '\\\\') {\n        this.advance(); // consume backslash\n        const escaped = this.advance();\n        switch (escaped) {\n          case 'n': value += '\\n'; break;\n          case 't': value += '\\t'; break;\n          case 'r': value += '\\r'; break;\n          case '\\\\': value += '\\\\'; break;\n          case '\"': value += '\"'; break;\n          case \"'\": value += \"'\"; break;\n          default: value += escaped; break;\n        }\n      } else {\n        value += this.advance();\n      }\n    }\n\n    if (this.isAtEnd()) {\n      this.addError('Unterminated string', { index: start, line: this.position.line, column: this.position.column });\n      return;\n    }\n\n    this.advance(); // consume closing quote\n    this.addToken(TokenType.STRING, value);\n  }\n\n  private scanQuotedIdentifier(): void {\n    const start = this.position.index - 1;\n    let value = '';\n\n    while (!this.isAtEnd() && this.peek() !== '`') {\n      value += this.advance();\n    }\n\n    if (this.isAtEnd()) {\n      this.addError('Unterminated quoted identifier', { index: start, line: this.position.line, column: this.position.column });\n      return;\n    }\n\n    this.advance(); // consume closing backtick\n    this.addToken(TokenType.QUOTED_IDENTIFIER, value);\n  }\n\n  private scanNumber(): void {\n    let value = '';\n    \n    // Integer part\n    while (this.isDigit(this.peek())) {\n      value += this.advance();\n    }\n\n    // Decimal part\n    if (this.peek() === '.' && this.isDigit(this.peekNext())) {\n      value += this.advance(); // consume '.'\n      while (this.isDigit(this.peek())) {\n        value += this.advance();\n      }\n    }\n\n    // Scientific notation\n    if (this.peek() === 'e' || this.peek() === 'E') {\n      value += this.advance();\n      if (this.peek() === '+' || this.peek() === '-') {\n        value += this.advance();\n      }\n      while (this.isDigit(this.peek())) {\n        value += this.advance();\n      }\n    }\n\n    // Check for timespan suffix\n    if (this.isAlpha(this.peek())) {\n      const suffix = this.scanTimespanSuffix();\n      if (suffix) {\n        this.addToken(TokenType.TIMESPAN, value + suffix);\n        return;\n      }\n    }\n\n    this.addToken(TokenType.NUMBER, value);\n  }\n\n  private scanTimespanSuffix(): string | null {\n    const suffixes = ['d', 'h', 'm', 's', 'ms', 'microsecond', 'nanosecond'];\n    let match = '';\n    \n    for (const suffix of suffixes) {\n      if (this.matchString(suffix)) {\n        return suffix;\n      }\n    }\n    \n    return null;\n  }\n\n  private scanIdentifier(): void {\n    let value = '';\n    \n    while (this.isAlphaNumeric(this.peek()) || this.peek() === '_') {\n      value += this.advance();\n    }\n\n    // Check for datetime literal\n    if (value === 'datetime' && this.peek() === '(') {\n      this.scanDatetime();\n      return;\n    }\n\n    // Check for GUID literal\n    if (this.isGuid(value)) {\n      this.addToken(TokenType.GUID, value);\n      return;\n    }\n\n    // Check if it's a keyword\n    const tokenType = KQLLexer.KEYWORDS.get(value.toLowerCase()) || TokenType.IDENTIFIER;\n    this.addToken(tokenType, value);\n  }\n\n  private scanDatetime(): void {\n    // datetime(2023-01-01T00:00:00Z)\n    let value = 'datetime';\n    \n    if (this.match('(')) {\n      value += '(';\n      \n      while (!this.isAtEnd() && this.peek() !== ')') {\n        value += this.advance();\n      }\n      \n      if (this.match(')')) {\n        value += ')';\n        this.addToken(TokenType.DATETIME, value);\n      } else {\n        this.addError('Unterminated datetime literal', this.position);\n      }\n    }\n  }\n\n  private scanComment(): void {\n    while (!this.isAtEnd() && this.peek() !== '\\n') {\n      this.advance();\n    }\n  }\n\n  private scanMultilineComment(): void {\n    while (!this.isAtEnd()) {\n      if (this.peek() === '*' && this.peekNext() === '/') {\n        this.advance(); // consume '*'\n        this.advance(); // consume '/'\n        break;\n      }\n      if (this.peek() === '\\n') {\n        this.position.line++;\n        this.position.column = 1;\n      }\n      this.advance();\n    }\n  }\n\n  private isDigit(char: string): boolean {\n    return char >= '0' && char <= '9';\n  }\n\n  private isAlpha(char: string): boolean {\n    return (char >= 'a' && char <= 'z') ||\n           (char >= 'A' && char <= 'Z') ||\n           char === '_';\n  }\n\n  private isAlphaNumeric(char: string): boolean {\n    return this.isAlpha(char) || this.isDigit(char);\n  }\n\n  private isGuid(value: string): boolean {\n    const guidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\n    return guidRegex.test(value);\n  }\n\n  private match(expected: string): boolean {\n    if (this.isAtEnd() || this.peek() !== expected) {\n      return false;\n    }\n    this.advance();\n    return true;\n  }\n\n  private matchWord(word: string): boolean {\n    const start = this.position.index;\n    \n    for (let i = 0; i < word.length; i++) {\n      if (this.isAtEnd() || this.peek().toLowerCase() !== word[i].toLowerCase()) {\n        this.position.index = start;\n        return false;\n      }\n      this.advance();\n    }\n    \n    // Make sure it's a complete word (not part of a larger identifier)\n    if (this.isAlphaNumeric(this.peek())) {\n      this.position.index = start;\n      return false;\n    }\n    \n    return true;\n  }\n\n  private matchString(str: string): boolean {\n    for (let i = 0; i < str.length; i++) {\n      if (this.isAtEnd() || this.peek() !== str[i]) {\n        return false;\n      }\n      this.advance();\n    }\n    return true;\n  }\n\n  private peek(): string {\n    if (this.isAtEnd()) return '\\0';\n    return this.input[this.position.index];\n  }\n\n  private peekNext(): string {\n    if (this.position.index + 1 >= this.input.length) return '\\0';\n    return this.input[this.position.index + 1];\n  }\n\n  private advance(): string {\n    if (this.isAtEnd()) return '\\0';\n    const char = this.input[this.position.index];\n    this.position.index++;\n    this.position.column++;\n    return char;\n  }\n\n  private isAtEnd(): boolean {\n    return this.position.index >= this.input.length;\n  }\n\n  private addToken(type: TokenType, value: string): void {\n    const start = this.position.index - value.length;\n    const token: Token = {\n      type,\n      value,\n      start,\n      end: this.position.index,\n      line: this.position.line,\n      column: this.position.column - value.length\n    };\n    this.tokens.push(token);\n  }\n\n  private addError(message: string, position: LexerPosition): void {\n    this.errors.push({ message, position });\n  }\n}","import { Token, TokenType } from '../lexer/types';\nimport {\n  ASTNode, Query, TableExpression, Operation, Expression,\n  WhereOperation, ProjectOperation, ExtendOperation, SummarizeOperation,\n  OrderOperation, TopOperation, LimitOperation, DistinctOperation,\n  JoinOperation, UnionOperation, BinaryExpression, UnaryExpression,\n  CallExpression, MemberExpression, ConditionalExpression,\n  Identifier, Literal, ProjectColumn, Assignment, Aggregation,\n  OrderByExpression, CaseExpression, CaseClause, ArrayExpression,\n  LetStatement, BinaryOperator, UnaryOperator, AggregationFunction,\n  JoinKind, LiteralType\n} from './ast';\n\nexport interface ParseError {\n  message: string;\n  token: Token;\n  expected?: TokenType[];\n}\n\nexport class KQLParser {\n  private tokens: Token[];\n  private current = 0;\n  private errors: ParseError[] = [];\n\n  constructor(tokens: Token[]) {\n    this.tokens = tokens.filter(t => \n      t.type !== TokenType.WHITESPACE && \n      t.type !== TokenType.COMMENT &&\n      t.type !== TokenType.NEWLINE\n    );\n  }\n\n  parse(): { query: Query | null, errors: ParseError[] } {\n    this.current = 0;\n    this.errors = [];\n\n    try {\n      const query = this.parseQuery();\n      return { query, errors: this.errors };\n    } catch (error) {\n      if (error instanceof Error) {\n        this.addError(error.message);\n      }\n      return { query: null, errors: this.errors };\n    }\n  }\n\n  private parseQuery(): Query {\n    // Handle let statements first\n    const letStatements: LetStatement[] = [];\n    while (this.match(TokenType.LET)) {\n      letStatements.push(this.parseLetStatement());\n      this.consume(TokenType.SEMICOLON, 'Expected \\';\\' after let statement');\n    }\n\n    const tableExpression = this.parseTableExpression();\n    const operations: Operation[] = [];\n\n    while (this.match(TokenType.PIPE)) {\n      operations.push(this.parseOperation());\n    }\n\n    const query: Query = {\n      type: 'Query',\n      tableExpression,\n      operations,\n      start: tableExpression.start,\n      end: this.previous().end\n    };\n\n    return query;\n  }\n\n  private parseLetStatement(): LetStatement {\n    const name = this.consume(TokenType.IDENTIFIER, 'Expected variable name').value;\n    this.consume(TokenType.EQUAL, 'Expected \\'=\\' after variable name');\n    const expression = this.parseExpression();\n\n    return {\n      type: 'LetStatement',\n      name,\n      expression\n    };\n  }\n\n  private parseTableExpression(): TableExpression {\n    const nameToken = this.consume(TokenType.IDENTIFIER, 'Expected table name');\n    let alias: string | undefined;\n\n    // Check for alias\n    if (this.check(TokenType.IDENTIFIER) && !this.checkPipe()) {\n      alias = this.advance().value;\n    }\n\n    return {\n      type: 'TableExpression',\n      name: nameToken.value,\n      alias,\n      start: nameToken.start,\n      end: this.previous().end\n    };\n  }\n\n  private parseOperation(): Operation {\n    const operationType = this.advance();\n\n    switch (operationType.type) {\n      case TokenType.WHERE:\n        return this.parseWhereOperation();\n      case TokenType.PROJECT:\n        return this.parseProjectOperation();\n      case TokenType.EXTEND:\n        return this.parseExtendOperation();\n      case TokenType.SUMMARIZE:\n        return this.parseSummarizeOperation();\n      case TokenType.ORDER:\n        return this.parseOrderOperation();\n      case TokenType.TOP:\n        return this.parseTopOperation();\n      case TokenType.LIMIT:\n        return this.parseLimitOperation();\n      case TokenType.DISTINCT:\n        return this.parseDistinctOperation();\n      case TokenType.JOIN:\n        return this.parseJoinOperation();\n      case TokenType.UNION:\n        return this.parseUnionOperation();\n      default:\n        throw new Error(`Unexpected operation: ${operationType.value}`);\n    }\n  }\n\n  private parseWhereOperation(): WhereOperation {\n    const predicate = this.parseExpression();\n    return {\n      type: 'WhereOperation',\n      predicate\n    };\n  }\n\n  private parseProjectOperation(): ProjectOperation {\n    const columns: ProjectColumn[] = [];\n\n    do {\n      const expression = this.parseExpression();\n      let alias: string | undefined;\n\n      // Check for alias (expression as alias)\n      if (this.check(TokenType.IDENTIFIER) && this.peek().value.toLowerCase() === 'as') {\n        this.advance(); // consume 'as'\n        alias = this.consume(TokenType.IDENTIFIER, 'Expected alias name').value;\n      }\n\n      columns.push({\n        type: 'ProjectColumn',\n        expression,\n        alias\n      });\n    } while (this.match(TokenType.COMMA));\n\n    return {\n      type: 'ProjectOperation',\n      columns\n    };\n  }\n\n  private parseExtendOperation(): ExtendOperation {\n    const assignments: Assignment[] = [];\n\n    do {\n      const name = this.consume(TokenType.IDENTIFIER, 'Expected column name').value;\n      this.consume(TokenType.EQUAL, 'Expected \\'=\\' after column name');\n      const expression = this.parseExpression();\n\n      assignments.push({\n        type: 'Assignment',\n        name,\n        expression\n      });\n    } while (this.match(TokenType.COMMA));\n\n    return {\n      type: 'ExtendOperation',\n      assignments\n    };\n  }\n\n  private parseSummarizeOperation(): SummarizeOperation {\n    const aggregations: Aggregation[] = [];\n\n    // Parse aggregations\n    do {\n      const functionName = this.consume(TokenType.IDENTIFIER, 'Expected aggregation function').value;\n      let expression: Expression | undefined;\n      let alias: string | undefined;\n\n      if (this.match(TokenType.LPAREN)) {\n        if (!this.check(TokenType.RPAREN)) {\n          expression = this.parseExpression();\n        }\n        this.consume(TokenType.RPAREN, 'Expected \\')\\' after aggregation arguments');\n      }\n\n      // Check for alias\n      if (this.check(TokenType.IDENTIFIER) && this.peek().value.toLowerCase() === 'as') {\n        this.advance(); // consume 'as'\n        alias = this.consume(TokenType.IDENTIFIER, 'Expected alias name').value;\n      }\n\n      aggregations.push({\n        type: 'Aggregation',\n        function: functionName as AggregationFunction,\n        expression,\n        alias\n      });\n    } while (this.match(TokenType.COMMA));\n\n    // Parse BY clause\n    let by: Expression[] | undefined;\n    if (this.match(TokenType.BY)) {\n      by = [];\n      do {\n        by.push(this.parseExpression());\n      } while (this.match(TokenType.COMMA));\n    }\n\n    return {\n      type: 'SummarizeOperation',\n      aggregations,\n      by\n    };\n  }\n\n  private parseOrderOperation(): OrderOperation {\n    this.consume(TokenType.BY, 'Expected \\'by\\' after \\'order\\'');\n    const orderBy: OrderByExpression[] = [];\n\n    do {\n      const expression = this.parseExpression();\n      let direction: 'asc' | 'desc' = 'asc';\n\n      if (this.match(TokenType.ASC)) {\n        direction = 'asc';\n      } else if (this.match(TokenType.DESC)) {\n        direction = 'desc';\n      }\n\n      orderBy.push({\n        type: 'OrderByExpression',\n        expression,\n        direction\n      });\n    } while (this.match(TokenType.COMMA));\n\n    return {\n      type: 'OrderOperation',\n      orderBy\n    };\n  }\n\n  private parseTopOperation(): TopOperation {\n    const count = this.parseExpression();\n    let by: OrderByExpression[] | undefined;\n\n    if (this.match(TokenType.BY)) {\n      by = [];\n      do {\n        const expression = this.parseExpression();\n        let direction: 'asc' | 'desc' = 'asc';\n\n        if (this.match(TokenType.ASC)) {\n          direction = 'asc';\n        } else if (this.match(TokenType.DESC)) {\n          direction = 'desc';\n        }\n\n        by.push({\n          type: 'OrderByExpression',\n          expression,\n          direction\n        });\n      } while (this.match(TokenType.COMMA));\n    }\n\n    return {\n      type: 'TopOperation',\n      count,\n      by\n    };\n  }\n\n  private parseLimitOperation(): LimitOperation {\n    const count = this.parseExpression();\n    return {\n      type: 'LimitOperation',\n      count\n    };\n  }\n\n  private parseDistinctOperation(): DistinctOperation {\n    let columns: Expression[] | undefined;\n\n    if (!this.checkPipe() && !this.isAtEnd()) {\n      columns = [];\n      do {\n        columns.push(this.parseExpression());\n      } while (this.match(TokenType.COMMA));\n    }\n\n    return {\n      type: 'DistinctOperation',\n      columns\n    };\n  }\n\n  private parseJoinOperation(): JoinOperation {\n    let joinKind: JoinKind = 'inner';\n\n    // Check for join kind\n    if (this.check(TokenType.INNER) || this.check(TokenType.LEFT) || \n        this.check(TokenType.RIGHT) || this.check(TokenType.FULL)) {\n      joinKind = this.advance().value.toLowerCase() as JoinKind;\n    }\n\n    const table = this.parseTableExpression();\n    this.consume(TokenType.ON, 'Expected \\'on\\' after join table');\n    const on = this.parseExpression();\n\n    return {\n      type: 'JoinOperation',\n      joinKind,\n      table,\n      on\n    };\n  }\n\n  private parseUnionOperation(): UnionOperation {\n    const tables: TableExpression[] = [];\n\n    do {\n      tables.push(this.parseTableExpression());\n    } while (this.match(TokenType.COMMA));\n\n    return {\n      type: 'UnionOperation',\n      tables\n    };\n  }\n\n  // Expression parsing with precedence\n  private parseExpression(): Expression {\n    return this.parseOrExpression();\n  }\n\n  private parseOrExpression(): Expression {\n    let expr = this.parseAndExpression();\n\n    while (this.match(TokenType.OR)) {\n      const operator = this.previous().value as BinaryOperator;\n      const right = this.parseAndExpression();\n      expr = {\n        type: 'BinaryExpression',\n        operator,\n        left: expr,\n        right\n      };\n    }\n\n    return expr;\n  }\n\n  private parseAndExpression(): Expression {\n    let expr = this.parseEqualityExpression();\n\n    while (this.match(TokenType.AND)) {\n      const operator = this.previous().value as BinaryOperator;\n      const right = this.parseEqualityExpression();\n      expr = {\n        type: 'BinaryExpression',\n        operator,\n        left: expr,\n        right\n      };\n    }\n\n    return expr;\n  }\n\n  private parseEqualityExpression(): Expression {\n    let expr = this.parseComparisonExpression();\n\n    while (this.match(TokenType.EQUAL, TokenType.NOT_EQUAL)) {\n      const operator = this.previous().value as BinaryOperator;\n      const right = this.parseComparisonExpression();\n      expr = {\n        type: 'BinaryExpression',\n        operator,\n        left: expr,\n        right\n      };\n    }\n\n    return expr;\n  }\n\n  private parseComparisonExpression(): Expression {\n    let expr = this.parseStringExpression();\n\n    while (this.match(TokenType.LESS_THAN, TokenType.LESS_EQUAL, \n                     TokenType.GREATER_THAN, TokenType.GREATER_EQUAL,\n                     TokenType.IN, TokenType.NOT_IN, TokenType.BETWEEN)) {\n      const operator = this.previous().value as BinaryOperator;\n      const right = this.parseStringExpression();\n      expr = {\n        type: 'BinaryExpression',\n        operator,\n        left: expr,\n        right\n      };\n    }\n\n    return expr;\n  }\n\n  private parseStringExpression(): Expression {\n    let expr = this.parseArithmeticExpression();\n\n    while (this.match(TokenType.CONTAINS, TokenType.NOT_CONTAINS,\n                     TokenType.STARTSWITH, TokenType.ENDSWITH,\n                     TokenType.MATCHES, TokenType.LIKE)) {\n      const operator = this.previous().value as BinaryOperator;\n      const right = this.parseArithmeticExpression();\n      expr = {\n        type: 'BinaryExpression',\n        operator,\n        left: expr,\n        right\n      };\n    }\n\n    return expr;\n  }\n\n  private parseArithmeticExpression(): Expression {\n    let expr = this.parseTermExpression();\n\n    while (this.match(TokenType.PLUS, TokenType.MINUS)) {\n      const operator = this.previous().value as BinaryOperator;\n      const right = this.parseTermExpression();\n      expr = {\n        type: 'BinaryExpression',\n        operator,\n        left: expr,\n        right\n      };\n    }\n\n    return expr;\n  }\n\n  private parseTermExpression(): Expression {\n    let expr = this.parseUnaryExpression();\n\n    while (this.match(TokenType.MULTIPLY, TokenType.DIVIDE, TokenType.MODULO)) {\n      const operator = this.previous().value as BinaryOperator;\n      const right = this.parseUnaryExpression();\n      expr = {\n        type: 'BinaryExpression',\n        operator,\n        left: expr,\n        right\n      };\n    }\n\n    return expr;\n  }\n\n  private parseUnaryExpression(): Expression {\n    if (this.match(TokenType.NOT, TokenType.MINUS, TokenType.PLUS)) {\n      const operator = this.previous().value as UnaryOperator;\n      const operand = this.parseUnaryExpression();\n      return {\n        type: 'UnaryExpression',\n        operator,\n        operand\n      };\n    }\n\n    return this.parsePostfixExpression();\n  }\n\n  private parsePostfixExpression(): Expression {\n    let expr = this.parsePrimaryExpression();\n\n    while (true) {\n      if (this.match(TokenType.DOT)) {\n        const property = this.consume(TokenType.IDENTIFIER, 'Expected property name after \\'.\\'');\n        expr = {\n          type: 'MemberExpression',\n          object: expr,\n          property: {\n            type: 'Identifier',\n            name: property.value\n          },\n          computed: false\n        };\n      } else if (this.match(TokenType.LBRACKET)) {\n        const property = this.parseExpression();\n        this.consume(TokenType.RBRACKET, 'Expected \\']\\' after array index');\n        expr = {\n          type: 'MemberExpression',\n          object: expr,\n          property,\n          computed: true\n        };\n      } else if (this.match(TokenType.LPAREN)) {\n        // Function call\n        const args: Expression[] = [];\n        if (!this.check(TokenType.RPAREN)) {\n          do {\n            args.push(this.parseExpression());\n          } while (this.match(TokenType.COMMA));\n        }\n        this.consume(TokenType.RPAREN, 'Expected \\')\\' after function arguments');\n        \n        if (expr.type === 'Identifier') {\n          expr = {\n            type: 'CallExpression',\n            function: expr.name,\n            arguments: args\n          };\n        } else {\n          throw new Error('Invalid function call');\n        }\n      } else {\n        break;\n      }\n    }\n\n    return expr;\n  }\n\n  private parsePrimaryExpression(): Expression {\n    if (this.match(TokenType.TRUE, TokenType.FALSE)) {\n      return {\n        type: 'Literal',\n        value: this.previous().value === 'true',\n        dataType: 'boolean'\n      };\n    }\n\n    if (this.match(TokenType.NULL)) {\n      return {\n        type: 'Literal',\n        value: null,\n        dataType: 'null'\n      };\n    }\n\n    if (this.match(TokenType.NUMBER)) {\n      const value = parseFloat(this.previous().value);\n      return {\n        type: 'Literal',\n        value,\n        dataType: 'number'\n      };\n    }\n\n    if (this.match(TokenType.STRING)) {\n      return {\n        type: 'Literal',\n        value: this.previous().value,\n        dataType: 'string'\n      };\n    }\n\n    if (this.match(TokenType.DATETIME)) {\n      return {\n        type: 'Literal',\n        value: this.previous().value,\n        dataType: 'datetime'\n      };\n    }\n\n    if (this.match(TokenType.TIMESPAN)) {\n      return {\n        type: 'Literal',\n        value: this.previous().value,\n        dataType: 'timespan'\n      };\n    }\n\n    if (this.match(TokenType.GUID)) {\n      return {\n        type: 'Literal',\n        value: this.previous().value,\n        dataType: 'guid'\n      };\n    }\n\n    if (this.match(TokenType.IDENTIFIER, TokenType.QUOTED_IDENTIFIER)) {\n      const token = this.previous();\n      return {\n        type: 'Identifier',\n        name: token.value,\n        quoted: token.type === TokenType.QUOTED_IDENTIFIER\n      };\n    }\n\n    if (this.match(TokenType.LPAREN)) {\n      const expr = this.parseExpression();\n      this.consume(TokenType.RPAREN, 'Expected \\')\\' after expression');\n      return expr;\n    }\n\n    if (this.match(TokenType.CASE)) {\n      return this.parseCaseExpression();\n    }\n\n    if (this.match(TokenType.LBRACKET)) {\n      return this.parseArrayExpression();\n    }\n\n    throw new Error(`Unexpected token: ${this.peek().value}`);\n  }\n\n  private parseCaseExpression(): CaseExpression {\n    const clauses: CaseClause[] = [];\n    let elseClause: Expression | undefined;\n\n    while (this.match(TokenType.WHEN)) {\n      const when = this.parseExpression();\n      this.consume(TokenType.THEN, 'Expected \\'then\\' after when condition');\n      const then = this.parseExpression();\n      clauses.push({\n        type: 'CaseClause',\n        when,\n        then\n      });\n    }\n\n    if (this.match(TokenType.ELSE)) {\n      elseClause = this.parseExpression();\n    }\n\n    this.consume(TokenType.END, 'Expected \\'end\\' to close case expression');\n\n    return {\n      type: 'CaseExpression',\n      clauses,\n      elseClause\n    };\n  }\n\n  private parseArrayExpression(): ArrayExpression {\n    const elements: Expression[] = [];\n\n    if (!this.check(TokenType.RBRACKET)) {\n      do {\n        elements.push(this.parseExpression());\n      } while (this.match(TokenType.COMMA));\n    }\n\n    this.consume(TokenType.RBRACKET, 'Expected \\']\\' after array elements');\n\n    return {\n      type: 'ArrayExpression',\n      elements\n    };\n  }\n\n  // Helper methods\n  private match(...types: TokenType[]): boolean {\n    for (const type of types) {\n      if (this.check(type)) {\n        this.advance();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private check(type: TokenType): boolean {\n    if (this.isAtEnd()) return false;\n    return this.peek().type === type;\n  }\n\n  private checkPipe(): boolean {\n    return this.check(TokenType.PIPE);\n  }\n\n  private advance(): Token {\n    if (!this.isAtEnd()) this.current++;\n    return this.previous();\n  }\n\n  private isAtEnd(): boolean {\n    return this.peek().type === TokenType.EOF;\n  }\n\n  private peek(): Token {\n    return this.tokens[this.current];\n  }\n\n  private previous(): Token {\n    return this.tokens[this.current - 1];\n  }\n\n  private consume(type: TokenType, message: string): Token {\n    if (this.check(type)) return this.advance();\n    \n    this.addError(message, [type]);\n    throw new Error(message);\n  }\n\n  private addError(message: string, expected?: TokenType[]): void {\n    this.errors.push({\n      message,\n      token: this.peek(),\n      expected\n    });\n  }\n}","import { Pool, PoolClient, QueryResult as PGQueryResult } from 'pg';\nimport { LRUCache } from 'lru-cache';\nimport { Query } from '../parser/ast';\nimport { KQLLexer } from '../lexer/lexer';\nimport { KQLParser } from '../parser/parser';\nimport { SQLGenerator } from './sql-generator';\nimport { QueryOptimizer } from './query-optimizer';\nimport {\n  ExecutionContext, QueryResult, ResultColumn, ResultRow,\n  QueryMetadata, PerformanceMetrics, CacheKey, CacheEntry\n} from './types';\n\nexport class QueryExecutor {\n  private db: Pool;\n  private cache: LRUCache<string, CacheEntry>;\n  private optimizer: QueryOptimizer;\n\n  constructor(db: Pool, cacheOptions?: { max?: number; ttl?: number }) {\n    this.db = db;\n    this.cache = new LRUCache({\n      max: cacheOptions?.max || 1000,\n      ttl: cacheOptions?.ttl || 5 * 60 * 1000, // 5 minutes default\n      updateAgeOnGet: true,\n      updateAgeOnHas: true\n    });\n    this.optimizer = new QueryOptimizer();\n  }\n\n  async executeKQL(kqlQuery: string, context: ExecutionContext): Promise<QueryResult> {\n    const startTime = Date.now();\n    let client: PoolClient | null = null;\n\n    try {\n      // Check cache first\n      if (context.cache !== false) {\n        const cacheKey = this.createCacheKey(kqlQuery, context);\n        const cached = this.getFromCache(cacheKey);\n        if (cached) {\n          return {\n            ...cached.result,\n            fromCache: true\n          };\n        }\n      }\n\n      // Parse KQL query\n      const parseStartTime = Date.now();\n      const lexer = new KQLLexer(kqlQuery);\n      const { tokens, errors: lexErrors } = lexer.tokenize();\n\n      if (lexErrors.length > 0) {\n        throw new Error(`Lexical errors: ${lexErrors.map(e => e.message).join(', ')}`);\n      }\n\n      const parser = new KQLParser(tokens);\n      const { query, errors: parseErrors } = parser.parse();\n\n      if (parseErrors.length > 0 || !query) {\n        throw new Error(`Parse errors: ${parseErrors.map(e => e.message).join(', ')}`);\n      }\n\n      const parseTime = Date.now() - parseStartTime;\n\n      // Optimize query\n      const planStartTime = Date.now();\n      const { optimizedQuery, plan } = this.optimizer.optimize(query);\n      const planTime = Date.now() - planStartTime;\n\n      // Generate SQL\n      const sqlGenerator = new SQLGenerator(context.organizationId);\n      const { sql, parameters } = sqlGenerator.generateSQL(optimizedQuery);\n\n      // Add time range filter if specified\n      let finalSql = sql;\n      let finalParameters = [...parameters];\n\n      if (context.timeRange) {\n        finalSql += ` AND timestamp BETWEEN $${parameters.length + 1} AND $${parameters.length + 2}`;\n        finalParameters.push(context.timeRange.start, context.timeRange.end);\n      }\n\n      // Add row limit if specified\n      if (context.maxRows) {\n        finalSql += ` LIMIT $${finalParameters.length + 1}`;\n        finalParameters.push(context.maxRows);\n      }\n\n      // Execute SQL query\n      const executionStartTime = Date.now();\n      client = await this.db.connect();\n\n      // Set query timeout if specified\n      if (context.timeout) {\n        await client.query(`SET statement_timeout = ${context.timeout}`);\n      }\n\n      const result = await client.query(finalSql, finalParameters);\n      const executionTime = Date.now() - executionStartTime;\n\n      // Process results\n      const queryResult = this.processResults(result, {\n        parseTime,\n        planTime,\n        executionTime,\n        totalTime: Date.now() - startTime,\n        memoryUsage: process.memoryUsage().heapUsed,\n        cpuTime: process.cpuUsage().system + process.cpuUsage().user,\n        ioOperations: 0 // Would need to be tracked separately\n      }, plan);\n\n      // Cache result if caching is enabled\n      if (context.cache !== false) {\n        const cacheKey = this.createCacheKey(kqlQuery, context);\n        this.setCache(cacheKey, queryResult);\n      }\n\n      return queryResult;\n\n    } catch (error) {\n      throw new Error(`Query execution failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    } finally {\n      if (client) {\n        client.release();\n      }\n    }\n  }\n\n  async explainKQL(kqlQuery: string, context: ExecutionContext): Promise<QueryMetadata> {\n    try {\n      // Parse and optimize query\n      const lexer = new KQLLexer(kqlQuery);\n      const { tokens, errors: lexErrors } = lexer.tokenize();\n\n      if (lexErrors.length > 0) {\n        throw new Error(`Lexical errors: ${lexErrors.map(e => e.message).join(', ')}`);\n      }\n\n      const parser = new KQLParser(tokens);\n      const { query, errors: parseErrors } = parser.parse();\n\n      if (parseErrors.length > 0 || !query) {\n        throw new Error(`Parse errors: ${parseErrors.map(e => e.message).join(', ')}`);\n      }\n\n      const { optimizedQuery, plan } = this.optimizer.optimize(query);\n\n      // Generate SQL and get execution plan\n      const sqlGenerator = new SQLGenerator(context.organizationId);\n      const { sql, parameters } = sqlGenerator.generateSQL(optimizedQuery);\n\n      let explainSql = `EXPLAIN (FORMAT JSON, ANALYZE false, BUFFERS false) ${sql}`;\n      let finalParameters = [...parameters];\n\n      if (context.timeRange) {\n        explainSql = explainSql.replace(sql, sql + ` AND timestamp BETWEEN $${parameters.length + 1} AND $${parameters.length + 2}`);\n        finalParameters.push(context.timeRange.start, context.timeRange.end);\n      }\n\n      const client = await this.db.connect();\n      const result = await client.query(explainSql, finalParameters);\n      client.release();\n\n      const pgPlan = result.rows[0]['QUERY PLAN'][0];\n\n      return {\n        totalRows: 0,\n        scannedRows: pgPlan['Plan']['Plan Rows'] || 0,\n        executionPlan: plan,\n        performance: {\n          parseTime: 0,\n          planTime: 0,\n          executionTime: pgPlan['Plan']['Total Cost'] || 0,\n          totalTime: 0,\n          memoryUsage: 0,\n          cpuTime: 0,\n          ioOperations: 0\n        }\n      };\n\n    } catch (error) {\n      throw new Error(`Query explanation failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  async validateKQL(kqlQuery: string): Promise<{ valid: boolean; errors: string[] }> {\n    try {\n      const lexer = new KQLLexer(kqlQuery);\n      const { tokens, errors: lexErrors } = lexer.tokenize();\n\n      if (lexErrors.length > 0) {\n        return {\n          valid: false,\n          errors: lexErrors.map(e => e.message)\n        };\n      }\n\n      const parser = new KQLParser(tokens);\n      const { query, errors: parseErrors } = parser.parse();\n\n      if (parseErrors.length > 0 || !query) {\n        return {\n          valid: false,\n          errors: parseErrors.map(e => e.message)\n        };\n      }\n\n      return { valid: true, errors: [] };\n\n    } catch (error) {\n      return {\n        valid: false,\n        errors: [error instanceof Error ? error.message : 'Unknown validation error']\n      };\n    }\n  }\n\n  private processResults(\n    pgResult: PGQueryResult,\n    performance: PerformanceMetrics,\n    plan: any\n  ): QueryResult {\n    // Convert PostgreSQL result to our format\n    const columns: ResultColumn[] = pgResult.fields.map(field => ({\n      name: field.name,\n      type: this.mapPostgreSQLType(field.dataTypeID),\n      nullable: true // PostgreSQL doesn't provide nullable info in result\n    }));\n\n    const rows: ResultRow[] = pgResult.rows.map(row => {\n      const resultRow: ResultRow = {};\n      columns.forEach(col => {\n        resultRow[col.name] = row[col.name];\n      });\n      return resultRow;\n    });\n\n    const metadata: QueryMetadata = {\n      totalRows: pgResult.rowCount || 0,\n      scannedRows: pgResult.rowCount || 0, // Would need to be tracked separately\n      executionPlan: plan,\n      performance\n    };\n\n    return {\n      columns,\n      rows,\n      metadata,\n      executionTime: performance.executionTime,\n      fromCache: false\n    };\n  }\n\n  private mapPostgreSQLType(dataTypeID: number): string {\n    // Map PostgreSQL data type IDs to readable types\n    const typeMap: Record<number, string> = {\n      16: 'boolean',     // bool\n      20: 'bigint',      // int8\n      21: 'smallint',    // int2\n      23: 'integer',     // int4\n      25: 'text',        // text\n      700: 'real',       // float4\n      701: 'double',     // float8\n      1043: 'varchar',   // varchar\n      1082: 'date',      // date\n      1114: 'timestamp', // timestamp\n      1184: 'timestamptz', // timestamptz\n      2950: 'uuid',      // uuid\n      3802: 'jsonb'      // jsonb\n    };\n\n    return typeMap[dataTypeID] || 'unknown';\n  }\n\n  private createCacheKey(kqlQuery: string, context: ExecutionContext): string {\n    const key: CacheKey = {\n      query: kqlQuery.trim(),\n      organizationId: context.organizationId,\n      timeRange: context.timeRange,\n      parameters: {\n        maxRows: context.maxRows,\n        timeout: context.timeout\n      }\n    };\n\n    return JSON.stringify(key);\n  }\n\n  private getFromCache(keyStr: string): CacheEntry | null {\n    const entry = this.cache.get(keyStr);\n    if (entry && entry.expiresAt > new Date()) {\n      return entry;\n    }\n    \n    if (entry) {\n      this.cache.delete(keyStr);\n    }\n    \n    return null;\n  }\n\n  private setCache(keyStr: string, result: QueryResult): void {\n    const entry: CacheEntry = {\n      key: JSON.parse(keyStr),\n      result,\n      createdAt: new Date(),\n      expiresAt: new Date(Date.now() + 5 * 60 * 1000), // 5 minutes\n      size: JSON.stringify(result).length\n    };\n\n    this.cache.set(keyStr, entry);\n  }\n\n  // Statistics and monitoring methods\n  getCacheStats(): { size: number; hits: number; misses: number } {\n    return {\n      size: this.cache.size,\n      hits: 0, // LRU cache doesn't provide this by default\n      misses: 0 // Would need to track separately\n    };\n  }\n\n  clearCache(): void {\n    this.cache.clear();\n  }\n\n  async getTableSchemas(organizationId: string): Promise<Record<string, any>> {\n    const client = await this.db.connect();\n    \n    try {\n      const result = await client.query(`\n        SELECT \n          table_name,\n          column_name,\n          data_type,\n          is_nullable,\n          column_default\n        FROM information_schema.columns \n        WHERE table_schema = 'public'\n        ORDER BY table_name, ordinal_position\n      `);\n\n      const schemas: Record<string, any> = {};\n      \n      for (const row of result.rows) {\n        if (!schemas[row.table_name]) {\n          schemas[row.table_name] = {\n            name: row.table_name,\n            columns: []\n          };\n        }\n        \n        schemas[row.table_name].columns.push({\n          name: row.column_name,\n          type: row.data_type,\n          nullable: row.is_nullable === 'YES',\n          defaultValue: row.column_default\n        });\n      }\n\n      return schemas;\n      \n    } finally {\n      client.release();\n    }\n  }\n}","import {\n  Query, TableExpression, Operation, Expression, WhereOperation,\n  ProjectOperation, ExtendOperation, SummarizeOperation, OrderOperation,\n  TopOperation, LimitOperation, DistinctOperation, JoinOperation,\n  BinaryExpression, UnaryExpression, CallExpression, MemberExpression,\n  Identifier, Literal, OrderByExpression, Aggregation, Assignment,\n  ProjectColumn, BinaryOperator, UnaryOperator\n} from '../parser/ast';\n\nexport class SQLGenerator {\n  private organizationId: string;\n  private aliases: Map<string, string> = new Map();\n  private parameterIndex = 1;\n  private parameters: any[] = [];\n\n  constructor(organizationId: string) {\n    this.organizationId = organizationId;\n  }\n\n  generateSQL(query: Query): { sql: string; parameters: any[] } {\n    this.aliases.clear();\n    this.parameterIndex = 1;\n    this.parameters = [];\n\n    const sql = this.visitQuery(query);\n    return { sql, parameters: this.parameters };\n  }\n\n  private visitQuery(query: Query): string {\n    let sql = this.visitTableExpression(query.tableExpression);\n\n    for (const operation of query.operations) {\n      sql = this.visitOperation(sql, operation);\n    }\n\n    return sql;\n  }\n\n  private visitTableExpression(table: TableExpression): string {\n    const tableName = this.escapeIdentifier(table.name);\n    let sql = `SELECT * FROM ${tableName}`;\n    \n    // Add organization filter\n    sql += ` WHERE organization_id = $${this.parameterIndex++}`;\n    this.parameters.push(this.organizationId);\n\n    if (table.alias) {\n      this.aliases.set(table.name, table.alias);\n      sql += ` AS ${this.escapeIdentifier(table.alias)}`;\n    }\n\n    return `(${sql})`;\n  }\n\n  private visitOperation(baseSql: string, operation: Operation): string {\n    switch (operation.type) {\n      case 'WhereOperation':\n        return this.visitWhereOperation(baseSql, operation);\n      case 'ProjectOperation':\n        return this.visitProjectOperation(baseSql, operation);\n      case 'ExtendOperation':\n        return this.visitExtendOperation(baseSql, operation);\n      case 'SummarizeOperation':\n        return this.visitSummarizeOperation(baseSql, operation);\n      case 'OrderOperation':\n        return this.visitOrderOperation(baseSql, operation);\n      case 'TopOperation':\n        return this.visitTopOperation(baseSql, operation);\n      case 'LimitOperation':\n        return this.visitLimitOperation(baseSql, operation);\n      case 'DistinctOperation':\n        return this.visitDistinctOperation(baseSql, operation);\n      case 'JoinOperation':\n        return this.visitJoinOperation(baseSql, operation);\n      default:\n        throw new Error(`Unsupported operation: ${(operation as any).type}`);\n    }\n  }\n\n  private visitWhereOperation(baseSql: string, operation: WhereOperation): string {\n    const condition = this.visitExpression(operation.predicate);\n    return `SELECT * FROM (${baseSql}) base WHERE ${condition}`;\n  }\n\n  private visitProjectOperation(baseSql: string, operation: ProjectOperation): string {\n    const columns = operation.columns.map(col => this.visitProjectColumn(col)).join(', ');\n    return `SELECT ${columns} FROM (${baseSql}) base`;\n  }\n\n  private visitProjectColumn(column: ProjectColumn): string {\n    const expr = this.visitExpression(column.expression);\n    if (column.alias) {\n      return `${expr} AS ${this.escapeIdentifier(column.alias)}`;\n    }\n    return expr;\n  }\n\n  private visitExtendOperation(baseSql: string, operation: ExtendOperation): string {\n    const baseColumns = 'base.*';\n    const extensions = operation.assignments.map(assignment => {\n      const expr = this.visitExpression(assignment.expression);\n      return `${expr} AS ${this.escapeIdentifier(assignment.name)}`;\n    }).join(', ');\n\n    return `SELECT ${baseColumns}, ${extensions} FROM (${baseSql}) base`;\n  }\n\n  private visitSummarizeOperation(baseSql: string, operation: SummarizeOperation): string {\n    const aggregations = operation.aggregations.map(agg => this.visitAggregation(agg)).join(', ');\n    \n    let sql = `SELECT ${aggregations}`;\n    \n    if (operation.by && operation.by.length > 0) {\n      const groupBy = operation.by.map(expr => this.visitExpression(expr)).join(', ');\n      sql += `, ${groupBy}`;\n      sql += ` FROM (${baseSql}) base GROUP BY ${groupBy}`;\n    } else {\n      sql += ` FROM (${baseSql}) base`;\n    }\n\n    return sql;\n  }\n\n  private visitAggregation(aggregation: Aggregation): string {\n    let sql = '';\n    \n    switch (aggregation.function) {\n      case 'count':\n        if (aggregation.expression) {\n          sql = `COUNT(${this.visitExpression(aggregation.expression)})`;\n        } else {\n          sql = 'COUNT(*)';\n        }\n        break;\n      case 'sum':\n        sql = `SUM(${this.visitExpression(aggregation.expression!)})`;\n        break;\n      case 'avg':\n        sql = `AVG(${this.visitExpression(aggregation.expression!)})`;\n        break;\n      case 'min':\n        sql = `MIN(${this.visitExpression(aggregation.expression!)})`;\n        break;\n      case 'max':\n        sql = `MAX(${this.visitExpression(aggregation.expression!)})`;\n        break;\n      case 'dcount':\n        sql = `COUNT(DISTINCT ${this.visitExpression(aggregation.expression!)})`;\n        break;\n      default:\n        throw new Error(`Unsupported aggregation function: ${aggregation.function}`);\n    }\n\n    if (aggregation.alias) {\n      sql += ` AS ${this.escapeIdentifier(aggregation.alias)}`;\n    }\n\n    return sql;\n  }\n\n  private visitOrderOperation(baseSql: string, operation: OrderOperation): string {\n    const orderBy = operation.orderBy.map(expr => this.visitOrderByExpression(expr)).join(', ');\n    return `SELECT * FROM (${baseSql}) base ORDER BY ${orderBy}`;\n  }\n\n  private visitOrderByExpression(orderBy: OrderByExpression): string {\n    const expr = this.visitExpression(orderBy.expression);\n    return `${expr} ${orderBy.direction.toUpperCase()}`;\n  }\n\n  private visitTopOperation(baseSql: string, operation: TopOperation): string {\n    const limit = this.visitExpression(operation.count);\n    let sql = `SELECT * FROM (${baseSql}) base`;\n\n    if (operation.by && operation.by.length > 0) {\n      const orderBy = operation.by.map(expr => this.visitOrderByExpression(expr)).join(', ');\n      sql += ` ORDER BY ${orderBy}`;\n    }\n\n    sql += ` LIMIT ${limit}`;\n    return sql;\n  }\n\n  private visitLimitOperation(baseSql: string, operation: LimitOperation): string {\n    const limit = this.visitExpression(operation.count);\n    return `SELECT * FROM (${baseSql}) base LIMIT ${limit}`;\n  }\n\n  private visitDistinctOperation(baseSql: string, operation: DistinctOperation): string {\n    if (operation.columns && operation.columns.length > 0) {\n      const columns = operation.columns.map(col => this.visitExpression(col)).join(', ');\n      return `SELECT DISTINCT ${columns} FROM (${baseSql}) base`;\n    } else {\n      return `SELECT DISTINCT * FROM (${baseSql}) base`;\n    }\n  }\n\n  private visitJoinOperation(baseSql: string, operation: JoinOperation): string {\n    const joinType = this.mapJoinKind(operation.joinKind);\n    const rightTable = this.visitTableExpression(operation.table);\n    const condition = this.visitExpression(operation.on);\n\n    return `SELECT * FROM (${baseSql}) base ${joinType} JOIN (${rightTable}) joined ON ${condition}`;\n  }\n\n  private mapJoinKind(joinKind: string): string {\n    switch (joinKind) {\n      case 'inner': return 'INNER';\n      case 'left': return 'LEFT';\n      case 'right': return 'RIGHT';\n      case 'full': return 'FULL OUTER';\n      case 'leftanti': return 'LEFT';\n      case 'rightsemi': return 'RIGHT';\n      default: return 'INNER';\n    }\n  }\n\n  private visitExpression(expression: Expression): string {\n    switch (expression.type) {\n      case 'BinaryExpression':\n        return this.visitBinaryExpression(expression);\n      case 'UnaryExpression':\n        return this.visitUnaryExpression(expression);\n      case 'CallExpression':\n        return this.visitCallExpression(expression);\n      case 'MemberExpression':\n        return this.visitMemberExpression(expression);\n      case 'Identifier':\n        return this.visitIdentifier(expression);\n      case 'Literal':\n        return this.visitLiteral(expression);\n      default:\n        throw new Error(`Unsupported expression type: ${(expression as any).type}`);\n    }\n  }\n\n  private visitBinaryExpression(expression: BinaryExpression): string {\n    const left = this.visitExpression(expression.left);\n    const right = this.visitExpression(expression.right);\n    const operator = this.mapBinaryOperator(expression.operator);\n\n    return `(${left} ${operator} ${right})`;\n  }\n\n  private mapBinaryOperator(operator: BinaryOperator): string {\n    switch (operator) {\n      case '==': return '=';\n      case '!=': return '!=';\n      case '<': return '<';\n      case '<=': return '<=';\n      case '>': return '>';\n      case '>=': return '>=';\n      case 'and': return 'AND';\n      case 'or': return 'OR';\n      case '+': return '+';\n      case '-': return '-';\n      case '*': return '*';\n      case '/': return '/';\n      case '%': return '%';\n      case 'contains': return 'ILIKE';\n      case '!contains': return 'NOT ILIKE';\n      case 'startswith': return 'ILIKE';\n      case 'endswith': return 'ILIKE';\n      case 'matches': return '~*';\n      case 'in': return 'IN';\n      case '!in': return 'NOT IN';\n      case 'like': return 'LIKE';\n      default:\n        throw new Error(`Unsupported binary operator: ${operator}`);\n    }\n  }\n\n  private visitUnaryExpression(expression: UnaryExpression): string {\n    const operand = this.visitExpression(expression.operand);\n    const operator = this.mapUnaryOperator(expression.operator);\n\n    return `${operator}${operand}`;\n  }\n\n  private mapUnaryOperator(operator: UnaryOperator): string {\n    switch (operator) {\n      case 'not': return 'NOT ';\n      case '-': return '-';\n      case '+': return '+';\n      default:\n        throw new Error(`Unsupported unary operator: ${operator}`);\n    }\n  }\n\n  private visitCallExpression(expression: CallExpression): string {\n    const args = expression.arguments.map(arg => this.visitExpression(arg)).join(', ');\n    const functionName = this.mapFunction(expression.function);\n\n    return `${functionName}(${args})`;\n  }\n\n  private mapFunction(functionName: string): string {\n    const functionMap: Record<string, string> = {\n      'strlen': 'LENGTH',\n      'substring': 'SUBSTRING',\n      'toupper': 'UPPER',\n      'tolower': 'LOWER',\n      'trim': 'TRIM',\n      'replace': 'REPLACE',\n      'split': 'STRING_TO_ARRAY',\n      'strcat': 'CONCAT',\n      'now': 'NOW',\n      'floor': 'FLOOR',\n      'ceil': 'CEIL',\n      'round': 'ROUND',\n      'abs': 'ABS',\n      'sqrt': 'SQRT',\n      'log': 'LN',\n      'pow': 'POWER',\n      'coalesce': 'COALESCE',\n      'isnull': 'IS NULL',\n      'isnotnull': 'IS NOT NULL',\n      'case': 'CASE'\n    };\n\n    return functionMap[functionName.toLowerCase()] || functionName.toUpperCase();\n  }\n\n  private visitMemberExpression(expression: MemberExpression): string {\n    const object = this.visitExpression(expression.object);\n    \n    if (expression.computed) {\n      const property = this.visitExpression(expression.property);\n      return `${object}[${property}]`;\n    } else {\n      const property = this.visitExpression(expression.property);\n      return `${object}.${property}`;\n    }\n  }\n\n  private visitIdentifier(expression: Identifier): string {\n    if (expression.quoted) {\n      return this.escapeIdentifier(expression.name);\n    }\n    return this.escapeIdentifier(expression.name);\n  }\n\n  private visitLiteral(expression: Literal): string {\n    if (expression.value === null) {\n      return 'NULL';\n    }\n\n    switch (expression.dataType) {\n      case 'string':\n        this.parameters.push(expression.value);\n        return `$${this.parameterIndex++}`;\n      case 'number':\n        this.parameters.push(expression.value);\n        return `$${this.parameterIndex++}`;\n      case 'boolean':\n        this.parameters.push(expression.value);\n        return `$${this.parameterIndex++}`;\n      case 'datetime':\n        // Parse datetime literal and convert to timestamp\n        const dateMatch = expression.value.match(/datetime\\(([^)]+)\\)/);\n        if (dateMatch) {\n          this.parameters.push(dateMatch[1]);\n          return `$${this.parameterIndex++}::timestamp`;\n        }\n        this.parameters.push(expression.value);\n        return `$${this.parameterIndex++}`;\n      case 'timespan':\n        // Convert timespan to interval\n        this.parameters.push(this.convertTimespanToInterval(expression.value));\n        return `$${this.parameterIndex++}::interval`;\n      case 'guid':\n        this.parameters.push(expression.value);\n        return `$${this.parameterIndex++}::uuid`;\n      default:\n        this.parameters.push(expression.value);\n        return `$${this.parameterIndex++}`;\n    }\n  }\n\n  private convertTimespanToInterval(timespan: string): string {\n    // Convert KQL timespan format to PostgreSQL interval\n    const timespanMap: Record<string, string> = {\n      'd': 'day',\n      'h': 'hour',\n      'm': 'minute',\n      's': 'second',\n      'ms': 'millisecond'\n    };\n\n    for (const [suffix, unit] of Object.entries(timespanMap)) {\n      if (timespan.endsWith(suffix)) {\n        const value = timespan.slice(0, -suffix.length);\n        return `${value} ${unit}`;\n      }\n    }\n\n    return timespan;\n  }\n\n  private escapeIdentifier(identifier: string): string {\n    // PostgreSQL identifier escaping\n    return `\"${identifier.replace(/\"/g, '\"\"')}\"`;\n  }\n}","export interface ExecutionContext {\n  organizationId: string;\n  userId: string;\n  timeRange?: TimeRange;\n  maxRows?: number;\n  timeout?: number;\n  cache?: boolean;\n}\n\nexport interface TimeRange {\n  start: Date;\n  end: Date;\n}\n\nexport interface QueryResult {\n  columns: ResultColumn[];\n  rows: ResultRow[];\n  metadata: QueryMetadata;\n  executionTime: number;\n  fromCache: boolean;\n}\n\nexport interface ResultColumn {\n  name: string;\n  type: string;\n  nullable: boolean;\n}\n\nexport interface ResultRow {\n  [columnName: string]: any;\n}\n\nexport interface QueryMetadata {\n  totalRows: number;\n  scannedRows: number;\n  executionPlan: ExecutionPlan;\n  performance: PerformanceMetrics;\n}\n\nexport interface ExecutionPlan {\n  steps: ExecutionStep[];\n  estimatedCost: number;\n  optimizations: string[];\n}\n\nexport interface ExecutionStep {\n  operation: string;\n  description: string;\n  estimatedRows: number;\n  estimatedCost: number;\n  index?: number;\n}\n\nexport interface PerformanceMetrics {\n  parseTime: number;\n  planTime: number;\n  executionTime: number;\n  totalTime: number;\n  memoryUsage: number;\n  cpuTime: number;\n  ioOperations: number;\n}\n\nexport interface TableSchema {\n  name: string;\n  columns: ColumnSchema[];\n  indexes: IndexSchema[];\n  partitions?: PartitionSchema[];\n}\n\nexport interface ColumnSchema {\n  name: string;\n  type: string;\n  nullable: boolean;\n  defaultValue?: any;\n  description?: string;\n}\n\nexport interface IndexSchema {\n  name: string;\n  columns: string[];\n  type: 'btree' | 'hash' | 'gin' | 'gist';\n  unique: boolean;\n  partial?: string;\n}\n\nexport interface PartitionSchema {\n  column: string;\n  type: 'range' | 'list' | 'hash';\n  values?: any[];\n}\n\nexport interface QueryOptimization {\n  type: OptimizationType;\n  description: string;\n  estimatedImprovement: number;\n  applied: boolean;\n}\n\nexport enum OptimizationType {\n  INDEX_USAGE = 'index_usage',\n  PREDICATE_PUSHDOWN = 'predicate_pushdown',\n  PROJECTION_PUSHDOWN = 'projection_pushdown',\n  JOIN_REORDER = 'join_reorder',\n  AGGREGATION_PUSHDOWN = 'aggregation_pushdown',\n  PARTITION_ELIMINATION = 'partition_elimination',\n  CONSTANT_FOLDING = 'constant_folding',\n  DEAD_CODE_ELIMINATION = 'dead_code_elimination'\n}\n\nexport interface CacheKey {\n  query: string;\n  organizationId: string;\n  timeRange?: TimeRange;\n  parameters?: Record<string, any>;\n}\n\nexport interface CacheEntry {\n  key: CacheKey;\n  result: QueryResult;\n  createdAt: Date;\n  expiresAt: Date;\n  size: number;\n}","import {\n  Query, TableExpression, Operation, Expression, WhereOperation,\n  ProjectOperation, ExtendOperation, SummarizeOperation, OrderOperation,\n  BinaryExpression, Identifier, Literal\n} from '../parser/ast';\nimport { QueryOptimization, OptimizationType, ExecutionPlan, ExecutionStep } from './types';\n\nexport class QueryOptimizer {\n  private optimizations: QueryOptimization[] = [];\n\n  optimize(query: Query): { optimizedQuery: Query; plan: ExecutionPlan } {\n    this.optimizations = [];\n    \n    let optimizedQuery = { ...query };\n    \n    // Apply optimizations in order of effectiveness\n    optimizedQuery = this.applyPredicatePushdown(optimizedQuery);\n    optimizedQuery = this.applyProjectionPushdown(optimizedQuery);\n    optimizedQuery = this.applyConstantFolding(optimizedQuery);\n    optimizedQuery = this.applyDeadCodeElimination(optimizedQuery);\n    optimizedQuery = this.reorderOperations(optimizedQuery);\n\n    const plan = this.generateExecutionPlan(optimizedQuery);\n    \n    return { optimizedQuery, plan };\n  }\n\n  private applyPredicatePushdown(query: Query): Query {\n    // Move WHERE conditions as early as possible in the pipeline\n    const whereOperations: WhereOperation[] = [];\n    const otherOperations: Operation[] = [];\n\n    // Collect all WHERE operations\n    for (const operation of query.operations) {\n      if (operation.type === 'WhereOperation') {\n        whereOperations.push(operation);\n      } else {\n        otherOperations.push(operation);\n      }\n    }\n\n    if (whereOperations.length > 1) {\n      // Combine multiple WHERE conditions with AND\n      const combinedPredicate = this.combinePredicates(whereOperations.map(op => op.predicate));\n      const combinedWhere: WhereOperation = {\n        type: 'WhereOperation',\n        predicate: combinedPredicate\n      };\n\n      this.optimizations.push({\n        type: OptimizationType.PREDICATE_PUSHDOWN,\n        description: `Combined ${whereOperations.length} WHERE conditions`,\n        estimatedImprovement: whereOperations.length * 0.1,\n        applied: true\n      });\n\n      return {\n        ...query,\n        operations: [combinedWhere, ...otherOperations]\n      };\n    }\n\n    return query;\n  }\n\n  private applyProjectionPushdown(query: Query): Query {\n    // Move PROJECT operations earlier to reduce data size\n    const projectOperations: ProjectOperation[] = [];\n    const otherOperations: Operation[] = [];\n\n    for (const operation of query.operations) {\n      if (operation.type === 'ProjectOperation') {\n        projectOperations.push(operation);\n      } else {\n        otherOperations.push(operation);\n      }\n    }\n\n    if (projectOperations.length > 0) {\n      // Find the last PROJECT operation (it determines final columns)\n      const lastProject = projectOperations[projectOperations.length - 1];\n      \n      // Check if we can move it earlier\n      const canMoveEarlier = this.canMoveProjectionEarlier(lastProject, otherOperations);\n      \n      if (canMoveEarlier) {\n        this.optimizations.push({\n          type: OptimizationType.PROJECTION_PUSHDOWN,\n          description: 'Moved projection earlier in pipeline',\n          estimatedImprovement: 0.2,\n          applied: true\n        });\n\n        // Move project operation earlier\n        const whereOps = otherOperations.filter(op => op.type === 'WhereOperation');\n        const nonWhereOps = otherOperations.filter(op => op.type !== 'WhereOperation');\n\n        return {\n          ...query,\n          operations: [...whereOps, lastProject, ...nonWhereOps]\n        };\n      }\n    }\n\n    return query;\n  }\n\n  private applyConstantFolding(query: Query): Query {\n    // Fold constant expressions at compile time\n    const foldedQuery = this.foldConstants(query);\n    \n    if (foldedQuery !== query) {\n      this.optimizations.push({\n        type: OptimizationType.CONSTANT_FOLDING,\n        description: 'Folded constant expressions',\n        estimatedImprovement: 0.05,\n        applied: true\n      });\n    }\n\n    return foldedQuery;\n  }\n\n  private applyDeadCodeElimination(query: Query): Query {\n    // Remove unused columns and operations\n    const usedColumns = this.findUsedColumns(query);\n    const eliminatedQuery = this.eliminateDeadCode(query, usedColumns);\n\n    if (eliminatedQuery !== query) {\n      this.optimizations.push({\n        type: OptimizationType.DEAD_CODE_ELIMINATION,\n        description: 'Eliminated unused columns and operations',\n        estimatedImprovement: 0.1,\n        applied: true\n      });\n    }\n\n    return eliminatedQuery;\n  }\n\n  private reorderOperations(query: Query): Query {\n    // Reorder operations for optimal performance\n    const reorderedOperations = [...query.operations];\n    \n    // Sort by operation cost (cheaper operations first)\n    reorderedOperations.sort((a, b) => {\n      const costA = this.getOperationCost(a);\n      const costB = this.getOperationCost(b);\n      return costA - costB;\n    });\n\n    // Ensure WHERE operations come before projections and summarizations\n    const whereOps = reorderedOperations.filter(op => op.type === 'WhereOperation');\n    const projectOps = reorderedOperations.filter(op => op.type === 'ProjectOperation');\n    const otherOps = reorderedOperations.filter(op => \n      op.type !== 'WhereOperation' && op.type !== 'ProjectOperation'\n    );\n\n    const finalOrder = [...whereOps, ...projectOps, ...otherOps];\n\n    if (JSON.stringify(finalOrder) !== JSON.stringify(query.operations)) {\n      this.optimizations.push({\n        type: OptimizationType.JOIN_REORDER,\n        description: 'Reordered operations for better performance',\n        estimatedImprovement: 0.15,\n        applied: true\n      });\n\n      return {\n        ...query,\n        operations: finalOrder\n      };\n    }\n\n    return query;\n  }\n\n  private combinePredicates(predicates: Expression[]): Expression {\n    if (predicates.length === 1) {\n      return predicates[0];\n    }\n\n    return predicates.reduce((combined, predicate) => ({\n      type: 'BinaryExpression',\n      operator: 'and',\n      left: combined,\n      right: predicate\n    }));\n  }\n\n  private canMoveProjectionEarlier(project: ProjectOperation, operations: Operation[]): boolean {\n    // Check if projection can be moved earlier without affecting results\n    const projectColumns = project.columns.map(col => {\n      if (col.expression.type === 'Identifier') {\n        return col.expression.name;\n      }\n      return null;\n    }).filter(Boolean);\n\n    // Check if any operation depends on columns not in the projection\n    for (const operation of operations) {\n      const usedColumns = this.getOperationColumns(operation);\n      const hasUnprojectedColumns = usedColumns.some(col => !projectColumns.includes(col));\n      \n      if (hasUnprojectedColumns) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private foldConstants(query: Query): Query {\n    // Recursively fold constant expressions\n    return {\n      ...query,\n      operations: query.operations.map(op => this.foldOperationConstants(op))\n    };\n  }\n\n  private foldOperationConstants(operation: Operation): Operation {\n    switch (operation.type) {\n      case 'WhereOperation':\n        return {\n          ...operation,\n          predicate: this.foldExpressionConstants(operation.predicate)\n        };\n      case 'ProjectOperation':\n        return {\n          ...operation,\n          columns: operation.columns.map(col => ({\n            ...col,\n            expression: this.foldExpressionConstants(col.expression)\n          }))\n        };\n      case 'ExtendOperation':\n        return {\n          ...operation,\n          assignments: operation.assignments.map(assignment => ({\n            ...assignment,\n            expression: this.foldExpressionConstants(assignment.expression)\n          }))\n        };\n      default:\n        return operation;\n    }\n  }\n\n  private foldExpressionConstants(expression: Expression): Expression {\n    if (expression.type === 'BinaryExpression') {\n      const left = this.foldExpressionConstants(expression.left);\n      const right = this.foldExpressionConstants(expression.right);\n\n      // If both operands are literals, fold the expression\n      if (left.type === 'Literal' && right.type === 'Literal') {\n        return this.evaluateBinaryExpression(expression.operator, left, right);\n      }\n\n      return {\n        ...expression,\n        left,\n        right\n      };\n    }\n\n    return expression;\n  }\n\n  private evaluateBinaryExpression(operator: string, left: Literal, right: Literal): Literal {\n    const leftVal = left.value;\n    const rightVal = right.value;\n\n    switch (operator) {\n      case '+':\n        return { type: 'Literal', value: leftVal + rightVal, dataType: 'number' };\n      case '-':\n        return { type: 'Literal', value: leftVal - rightVal, dataType: 'number' };\n      case '*':\n        return { type: 'Literal', value: leftVal * rightVal, dataType: 'number' };\n      case '/':\n        return { type: 'Literal', value: leftVal / rightVal, dataType: 'number' };\n      case '==':\n        return { type: 'Literal', value: leftVal === rightVal, dataType: 'boolean' };\n      case '!=':\n        return { type: 'Literal', value: leftVal !== rightVal, dataType: 'boolean' };\n      case '<':\n        return { type: 'Literal', value: leftVal < rightVal, dataType: 'boolean' };\n      case '<=':\n        return { type: 'Literal', value: leftVal <= rightVal, dataType: 'boolean' };\n      case '>':\n        return { type: 'Literal', value: leftVal > rightVal, dataType: 'boolean' };\n      case '>=':\n        return { type: 'Literal', value: leftVal >= rightVal, dataType: 'boolean' };\n      default:\n        return left; // Return original if can't fold\n    }\n  }\n\n  private findUsedColumns(query: Query): Set<string> {\n    const usedColumns = new Set<string>();\n    \n    // Add columns from table expression\n    usedColumns.add('*'); // Start with all columns\n    \n    // Find columns used in operations\n    for (const operation of query.operations) {\n      const operationColumns = this.getOperationColumns(operation);\n      operationColumns.forEach(col => usedColumns.add(col));\n    }\n    \n    return usedColumns;\n  }\n\n  private getOperationColumns(operation: Operation): string[] {\n    const columns: string[] = [];\n    \n    switch (operation.type) {\n      case 'WhereOperation':\n        columns.push(...this.getExpressionColumns(operation.predicate));\n        break;\n      case 'ProjectOperation':\n        operation.columns.forEach(col => {\n          columns.push(...this.getExpressionColumns(col.expression));\n        });\n        break;\n      case 'ExtendOperation':\n        operation.assignments.forEach(assignment => {\n          columns.push(...this.getExpressionColumns(assignment.expression));\n        });\n        break;\n      case 'SummarizeOperation':\n        operation.aggregations.forEach(agg => {\n          if (agg.expression) {\n            columns.push(...this.getExpressionColumns(agg.expression));\n          }\n        });\n        if (operation.by) {\n          operation.by.forEach(expr => {\n            columns.push(...this.getExpressionColumns(expr));\n          });\n        }\n        break;\n      case 'OrderOperation':\n        operation.orderBy.forEach(orderBy => {\n          columns.push(...this.getExpressionColumns(orderBy.expression));\n        });\n        break;\n    }\n    \n    return columns;\n  }\n\n  private getExpressionColumns(expression: Expression): string[] {\n    const columns: string[] = [];\n    \n    switch (expression.type) {\n      case 'Identifier':\n        columns.push(expression.name);\n        break;\n      case 'BinaryExpression':\n        columns.push(...this.getExpressionColumns(expression.left));\n        columns.push(...this.getExpressionColumns(expression.right));\n        break;\n      case 'UnaryExpression':\n        columns.push(...this.getExpressionColumns(expression.operand));\n        break;\n      case 'CallExpression':\n        expression.arguments.forEach(arg => {\n          columns.push(...this.getExpressionColumns(arg));\n        });\n        break;\n      case 'MemberExpression':\n        columns.push(...this.getExpressionColumns(expression.object));\n        if (expression.computed) {\n          columns.push(...this.getExpressionColumns(expression.property));\n        }\n        break;\n    }\n    \n    return columns;\n  }\n\n  private eliminateDeadCode(query: Query, usedColumns: Set<string>): Query {\n    // For now, return the query as-is\n    // In a full implementation, this would remove unused projections and operations\n    return query;\n  }\n\n  private getOperationCost(operation: Operation): number {\n    // Assign relative costs to operations\n    switch (operation.type) {\n      case 'WhereOperation': return 1;\n      case 'ProjectOperation': return 2;\n      case 'ExtendOperation': return 3;\n      case 'OrderOperation': return 8;\n      case 'TopOperation': return 6;\n      case 'LimitOperation': return 1;\n      case 'DistinctOperation': return 7;\n      case 'SummarizeOperation': return 9;\n      case 'JoinOperation': return 10;\n      case 'UnionOperation': return 5;\n      default: return 5;\n    }\n  }\n\n  private generateExecutionPlan(query: Query): ExecutionPlan {\n    const steps: ExecutionStep[] = [];\n    let currentRows = 1000000; // Estimated starting rows\n    let totalCost = 0;\n\n    // Table scan step\n    steps.push({\n      operation: 'TableScan',\n      description: `Scan table: ${query.tableExpression.name}`,\n      estimatedRows: currentRows,\n      estimatedCost: 10,\n      index: 0\n    });\n    totalCost += 10;\n\n    // Operation steps\n    query.operations.forEach((operation, index) => {\n      const step = this.createExecutionStep(operation, currentRows, index + 1);\n      steps.push(step);\n      currentRows = step.estimatedRows;\n      totalCost += step.estimatedCost;\n    });\n\n    return {\n      steps,\n      estimatedCost: totalCost,\n      optimizations: this.optimizations.filter(opt => opt.applied).map(opt => opt.description)\n    };\n  }\n\n  private createExecutionStep(operation: Operation, inputRows: number, index: number): ExecutionStep {\n    let estimatedRows = inputRows;\n    let estimatedCost = 0;\n    let description = '';\n\n    switch (operation.type) {\n      case 'WhereOperation':\n        estimatedRows = Math.floor(inputRows * 0.1); // Assume 10% selectivity\n        estimatedCost = inputRows * 0.001;\n        description = 'Filter rows with WHERE condition';\n        break;\n      case 'ProjectOperation':\n        // Rows stay the same, but cost is minimal\n        estimatedCost = inputRows * 0.0001;\n        description = `Project ${operation.columns.length} columns`;\n        break;\n      case 'SummarizeOperation':\n        estimatedRows = Math.floor(inputRows * 0.01); // Assume 1% unique groups\n        estimatedCost = inputRows * 0.01;\n        description = `Summarize with ${operation.aggregations.length} aggregations`;\n        break;\n      case 'OrderOperation':\n        estimatedCost = inputRows * Math.log2(inputRows) * 0.001;\n        description = `Sort by ${operation.orderBy.length} columns`;\n        break;\n      case 'TopOperation':\n        estimatedRows = Math.min(inputRows, 1000); // Assume top 1000\n        estimatedCost = inputRows * Math.log2(inputRows) * 0.001;\n        description = 'Take top N rows';\n        break;\n      case 'LimitOperation':\n        estimatedRows = Math.min(inputRows, 1000); // Assume limit 1000\n        estimatedCost = 1;\n        description = 'Limit result set';\n        break;\n      case 'DistinctOperation':\n        estimatedRows = Math.floor(inputRows * 0.8); // Assume 80% unique\n        estimatedCost = inputRows * 0.01;\n        description = 'Remove duplicate rows';\n        break;\n      default:\n        estimatedCost = inputRows * 0.001;\n        description = `Execute ${operation.type}`;\n    }\n\n    return {\n      operation: operation.type,\n      description,\n      estimatedRows,\n      estimatedCost,\n      index\n    };\n  }\n\n  getOptimizations(): QueryOptimization[] {\n    return this.optimizations;\n  }\n}","export interface CompletionItem {\n  label: string;\n  kind: CompletionItemKind;\n  detail?: string;\n  documentation?: string;\n  insertText?: string;\n  filterText?: string;\n  sortText?: string;\n  range?: Range;\n  command?: Command;\n  additionalTextEdits?: TextEdit[];\n  commitCharacters?: string[];\n  data?: any;\n}\n\nexport enum CompletionItemKind {\n  Text = 1,\n  Method = 2,\n  Function = 3,\n  Constructor = 4,\n  Field = 5,\n  Variable = 6,\n  Class = 7,\n  Interface = 8,\n  Module = 9,\n  Property = 10,\n  Unit = 11,\n  Value = 12,\n  Enum = 13,\n  Keyword = 14,\n  Snippet = 15,\n  Color = 16,\n  File = 17,\n  Reference = 18,\n  Folder = 19,\n  EnumMember = 20,\n  Constant = 21,\n  Struct = 22,\n  Event = 23,\n  Operator = 24,\n  TypeParameter = 25,\n  Table = 26,\n  Column = 27\n}\n\nexport interface Range {\n  start: Position;\n  end: Position;\n}\n\nexport interface Position {\n  line: number;\n  character: number;\n}\n\nexport interface TextEdit {\n  range: Range;\n  newText: string;\n}\n\nexport interface Command {\n  title: string;\n  command: string;\n  arguments?: any[];\n}\n\nexport interface CompletionContext {\n  triggerKind: CompletionTriggerKind;\n  triggerCharacter?: string;\n}\n\nexport enum CompletionTriggerKind {\n  Invoked = 1,\n  TriggerCharacter = 2,\n  TriggerForIncompleteCompletions = 3\n}\n\nexport interface Diagnostic {\n  range: Range;\n  severity: DiagnosticSeverity;\n  code?: string | number;\n  source?: string;\n  message: string;\n  relatedInformation?: DiagnosticRelatedInformation[];\n}\n\nexport enum DiagnosticSeverity {\n  Error = 1,\n  Warning = 2,\n  Information = 3,\n  Hint = 4\n}\n\nexport interface DiagnosticRelatedInformation {\n  location: Location;\n  message: string;\n}\n\nexport interface Location {\n  uri: string;\n  range: Range;\n}\n\nexport interface HoverInfo {\n  contents: string | MarkupContent;\n  range?: Range;\n}\n\nexport interface MarkupContent {\n  kind: 'plaintext' | 'markdown';\n  value: string;\n}\n\nexport interface SignatureHelp {\n  signatures: SignatureInformation[];\n  activeSignature?: number;\n  activeParameter?: number;\n}\n\nexport interface SignatureInformation {\n  label: string;\n  documentation?: string | MarkupContent;\n  parameters?: ParameterInformation[];\n}\n\nexport interface ParameterInformation {\n  label: string | [number, number];\n  documentation?: string | MarkupContent;\n}\n\nexport interface SchemaInfo {\n  tables: TableInfo[];\n  functions: FunctionInfo[];\n  operators: OperatorInfo[];\n  keywords: KeywordInfo[];\n}\n\nexport interface TableInfo {\n  name: string;\n  description?: string;\n  columns: ColumnInfo[];\n  sampleQueries?: string[];\n}\n\nexport interface ColumnInfo {\n  name: string;\n  type: string;\n  description?: string;\n  nullable: boolean;\n  examples?: any[];\n}\n\nexport interface FunctionInfo {\n  name: string;\n  description?: string;\n  parameters: ParameterInfo[];\n  returnType: string;\n  examples?: string[];\n  category: 'aggregation' | 'scalar' | 'window' | 'table';\n}\n\nexport interface ParameterInfo {\n  name: string;\n  type: string;\n  optional: boolean;\n  description?: string;\n}\n\nexport interface OperatorInfo {\n  operator: string;\n  description: string;\n  leftType: string;\n  rightType: string;\n  returnType: string;\n  examples: string[];\n}\n\nexport interface KeywordInfo {\n  keyword: string;\n  description: string;\n  category: 'command' | 'function' | 'operator' | 'type';\n  examples: string[];\n}\n\nexport interface QueryContext {\n  position: Position;\n  text: string;\n  currentTable?: string;\n  availableColumns?: string[];\n  inOperator?: boolean;\n  operatorContext?: string;\n  functionContext?: {\n    name: string;\n    parameterIndex: number;\n  };\n}","import { KQLLexer } from '../lexer/lexer';\nimport { TokenType } from '../lexer/types';\nimport { SchemaProvider } from './schema-provider';\nimport {\n  CompletionItem, CompletionItemKind, CompletionContext, CompletionTriggerKind,\n  Position, Range, QueryContext\n} from './types';\n\nexport class CompletionProvider {\n  private schemaProvider: SchemaProvider;\n\n  constructor(schemaProvider: SchemaProvider) {\n    this.schemaProvider = schemaProvider;\n  }\n\n  async provideCompletions(\n    text: string,\n    position: Position,\n    context?: CompletionContext\n  ): Promise<CompletionItem[]> {\n    const queryContext = this.analyzeQueryContext(text, position);\n    const completions: CompletionItem[] = [];\n\n    // Determine what kind of completions to provide based on context\n    if (this.isAtBeginning(queryContext)) {\n      // Table names at the beginning\n      completions.push(...this.getTableCompletions());\n    } else if (this.isAfterPipe(queryContext)) {\n      // Commands after pipe\n      completions.push(...this.getCommandCompletions());\n    } else if (this.isInWhereClause(queryContext)) {\n      // Column names and operators in WHERE clause\n      completions.push(...this.getColumnCompletions(queryContext.currentTable));\n      completions.push(...this.getOperatorCompletions());\n      completions.push(...this.getFunctionCompletions());\n    } else if (this.isInProjectClause(queryContext)) {\n      // Column names in PROJECT clause\n      completions.push(...this.getColumnCompletions(queryContext.currentTable));\n      completions.push(...this.getFunctionCompletions());\n    } else if (this.isInSummarizeClause(queryContext)) {\n      // Aggregation functions and columns\n      completions.push(...this.getAggregationCompletions());\n      completions.push(...this.getColumnCompletions(queryContext.currentTable));\n    } else if (this.isInFunctionCall(queryContext)) {\n      // Function parameters\n      completions.push(...this.getFunctionParameterCompletions(queryContext.functionContext!));\n    } else {\n      // General completions\n      completions.push(...this.getGeneralCompletions(queryContext));\n    }\n\n    return this.filterAndSortCompletions(completions, queryContext);\n  }\n\n  private analyzeQueryContext(text: string, position: Position): QueryContext {\n    const lines = text.split('\\n');\n    const currentLine = lines[position.line] || '';\n    const beforeCursor = currentLine.substring(0, position.character);\n    \n    // Tokenize the text up to the cursor position\n    const textToCursor = lines.slice(0, position.line).join('\\n') + \n                        (position.line < lines.length ? '\\n' + beforeCursor : beforeCursor);\n    \n    const lexer = new KQLLexer(textToCursor);\n    const { tokens } = lexer.tokenize();\n\n    // Find current table\n    let currentTable: string | undefined;\n    for (let i = 0; i < tokens.length; i++) {\n      if (tokens[i].type === TokenType.IDENTIFIER && \n          (i === 0 || tokens[i - 1].type === TokenType.PIPE)) {\n        const tableName = tokens[i].value;\n        if (this.schemaProvider.getTable(tableName)) {\n          currentTable = tableName;\n        }\n      }\n    }\n\n    // Determine context\n    const context: QueryContext = {\n      position,\n      text: textToCursor,\n      currentTable,\n      availableColumns: currentTable ? \n        this.schemaProvider.getColumns(currentTable).map(c => c.name) : []\n    };\n\n    // Check if we're in a function call\n    context.functionContext = this.getFunctionContext(tokens, position);\n\n    return context;\n  }\n\n  private isAtBeginning(context: QueryContext): boolean {\n    const trimmed = context.text.trim();\n    return trimmed === '' || !trimmed.includes('|');\n  }\n\n  private isAfterPipe(context: QueryContext): boolean {\n    const lastPipeIndex = context.text.lastIndexOf('|');\n    if (lastPipeIndex === -1) return false;\n    \n    const afterPipe = context.text.substring(lastPipeIndex + 1).trim();\n    return afterPipe === '' || afterPipe.split(/\\s+/).length === 1;\n  }\n\n  private isInWhereClause(context: QueryContext): boolean {\n    const lastPipeIndex = context.text.lastIndexOf('|');\n    const afterPipe = lastPipeIndex >= 0 ? context.text.substring(lastPipeIndex + 1) : context.text;\n    return /\\\\bwhere\\\\b/i.test(afterPipe) && !this.isAfterPipe(context);\n  }\n\n  private isInProjectClause(context: QueryContext): boolean {\n    const lastPipeIndex = context.text.lastIndexOf('|');\n    const afterPipe = lastPipeIndex >= 0 ? context.text.substring(lastPipeIndex + 1) : context.text;\n    return /\\\\bproject\\\\b/i.test(afterPipe) && !this.isAfterPipe(context);\n  }\n\n  private isInSummarizeClause(context: QueryContext): boolean {\n    const lastPipeIndex = context.text.lastIndexOf('|');\n    const afterPipe = lastPipeIndex >= 0 ? context.text.substring(lastPipeIndex + 1) : context.text;\n    return /\\\\bsummarize\\\\b/i.test(afterPipe) && !this.isAfterPipe(context);\n  }\n\n  private isInFunctionCall(context: QueryContext): boolean {\n    return context.functionContext !== undefined;\n  }\n\n  private getFunctionContext(tokens: any[], position: Position): { name: string; parameterIndex: number } | undefined {\n    // Find the most recent function call that contains the cursor position\n    let functionName = '';\n    let parameterIndex = 0;\n    let parenDepth = 0;\n    let inFunction = false;\n\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      const token = tokens[i];\n      \n      if (token.type === TokenType.RPAREN) {\n        parenDepth++;\n      } else if (token.type === TokenType.LPAREN) {\n        parenDepth--;\n        if (parenDepth < 0 && i > 0 && tokens[i - 1].type === TokenType.IDENTIFIER) {\n          functionName = tokens[i - 1].value;\n          inFunction = true;\n          break;\n        }\n      } else if (token.type === TokenType.COMMA && parenDepth === 0) {\n        parameterIndex++;\n      }\n    }\n\n    return inFunction ? { name: functionName, parameterIndex } : undefined;\n  }\n\n  private getTableCompletions(): CompletionItem[] {\n    return this.schemaProvider.getTables().map(table => ({\n      label: table.name,\n      kind: CompletionItemKind.Table,\n      detail: 'Table',\n      documentation: table.description,\n      insertText: table.name,\n      sortText: `0_${table.name}`\n    }));\n  }\n\n  private getCommandCompletions(): CompletionItem[] {\n    const commands = [\n      'where', 'project', 'extend', 'summarize', 'order', 'top', 'limit', \n      'distinct', 'join', 'union', 'let'\n    ];\n\n    return commands.map(cmd => ({\n      label: cmd,\n      kind: CompletionItemKind.Keyword,\n      detail: 'Command',\n      documentation: this.getCommandDocumentation(cmd),\n      insertText: cmd + ' ',\n      sortText: `1_${cmd}`\n    }));\n  }\n\n  private getColumnCompletions(tableName?: string): CompletionItem[] {\n    if (!tableName) return [];\n\n    const columns = this.schemaProvider.getColumns(tableName);\n    return columns.map(column => ({\n      label: column.name,\n      kind: CompletionItemKind.Field,\n      detail: `${column.type}${column.nullable ? ' (nullable)' : ''}`,\n      documentation: column.description,\n      insertText: column.name,\n      sortText: `2_${column.name}`\n    }));\n  }\n\n  private getOperatorCompletions(): CompletionItem[] {\n    const operators = this.schemaProvider.getOperators();\n    return operators.map(op => ({\n      label: op.operator,\n      kind: CompletionItemKind.Operator,\n      detail: `${op.leftType} ${op.operator} ${op.rightType} -> ${op.returnType}`,\n      documentation: op.description,\n      insertText: op.operator,\n      sortText: `3_${op.operator}`\n    }));\n  }\n\n  private getFunctionCompletions(): CompletionItem[] {\n    const functions = this.schemaProvider.getFunctions();\n    return functions.map(func => ({\n      label: func.name,\n      kind: CompletionItemKind.Function,\n      detail: this.getFunctionSignature(func),\n      documentation: func.description,\n      insertText: this.getFunctionInsertText(func),\n      sortText: `4_${func.name}`\n    }));\n  }\n\n  private getAggregationCompletions(): CompletionItem[] {\n    const functions = this.schemaProvider.getFunctions().filter(f => f.category === 'aggregation');\n    return functions.map(func => ({\n      label: func.name,\n      kind: CompletionItemKind.Function,\n      detail: this.getFunctionSignature(func),\n      documentation: func.description,\n      insertText: this.getFunctionInsertText(func),\n      sortText: `1_${func.name}` // Higher priority for aggregations in summarize\n    }));\n  }\n\n  private getFunctionParameterCompletions(functionContext: { name: string; parameterIndex: number }): CompletionItem[] {\n    const func = this.schemaProvider.getFunction(functionContext.name);\n    if (!func || functionContext.parameterIndex >= func.parameters.length) {\n      return [];\n    }\n\n    const parameter = func.parameters[functionContext.parameterIndex];\n    const completions: CompletionItem[] = [];\n\n    // Add type-specific completions\n    if (parameter.type === 'timespan') {\n      completions.push(...this.getTimespanCompletions());\n    } else if (parameter.type === 'string' && parameter.name === 'column') {\n      // Column suggestions for column parameters\n      completions.push(...this.getColumnCompletions());\n    }\n\n    return completions;\n  }\n\n  private getTimespanCompletions(): CompletionItem[] {\n    const timespans = ['1s', '30s', '1m', '5m', '15m', '30m', '1h', '6h', '12h', '1d', '7d', '30d'];\n    return timespans.map(ts => ({\n      label: ts,\n      kind: CompletionItemKind.Value,\n      detail: 'Timespan',\n      insertText: ts,\n      sortText: `1_${ts}`\n    }));\n  }\n\n  private getGeneralCompletions(context: QueryContext): CompletionItem[] {\n    const completions: CompletionItem[] = [];\n    \n    // Add keywords\n    completions.push(...this.getKeywordCompletions());\n    \n    // Add columns if we have a current table\n    if (context.currentTable) {\n      completions.push(...this.getColumnCompletions(context.currentTable));\n    }\n    \n    // Add functions\n    completions.push(...this.getFunctionCompletions());\n    \n    return completions;\n  }\n\n  private getKeywordCompletions(): CompletionItem[] {\n    const keywords = this.schemaProvider.getKeywords();\n    return keywords.map(keyword => ({\n      label: keyword.keyword,\n      kind: CompletionItemKind.Keyword,\n      detail: keyword.category,\n      documentation: keyword.description,\n      insertText: keyword.keyword,\n      sortText: `5_${keyword.keyword}`\n    }));\n  }\n\n  private getFunctionSignature(func: any): string {\n    const params = func.parameters.map((p: any) => \n      `${p.name}: ${p.type}${p.optional ? '?' : ''}`\n    ).join(', ');\n    return `${func.name}(${params}) -> ${func.returnType}`;\n  }\n\n  private getFunctionInsertText(func: any): string {\n    const requiredParams = func.parameters.filter((p: any) => !p.optional);\n    if (requiredParams.length === 0) {\n      return `${func.name}()`;\n    }\n    \n    const paramPlaceholders = requiredParams.map((_: any, index: number) => `$${index + 1}`).join(', ');\n    return `${func.name}(${paramPlaceholders})`;\n  }\n\n  private getCommandDocumentation(command: string): string {\n    const docs: Record<string, string> = {\n      where: 'Filters a table to the subset of rows that satisfy a predicate',\n      project: 'Select what columns to include, rename or drop, and insert new computed columns',\n      extend: 'Create calculated columns and append them to the result set',\n      summarize: 'Produce a table that aggregates the content of the input table',\n      order: 'Sort the rows of the input table by one or more columns',\n      top: 'Returns the first N records sorted by the specified columns',\n      limit: 'Return up to the specified number of rows',\n      distinct: 'Produces a table with the distinct combination of the provided columns',\n      join: 'Merge the rows of two tables to form a new table',\n      union: 'Takes two or more tables and returns the rows of all of them'\n    };\n    return docs[command] || '';\n  }\n\n  private filterAndSortCompletions(completions: CompletionItem[], context: QueryContext): CompletionItem[] {\n    // Get the current word being typed\n    const currentWord = this.getCurrentWord(context);\n    \n    if (!currentWord) {\n      return completions.sort((a, b) => (a.sortText || a.label).localeCompare(b.sortText || b.label));\n    }\n\n    // Filter completions that start with the current word\n    const filtered = completions.filter(item => \n      item.label.toLowerCase().startsWith(currentWord.toLowerCase()) ||\n      (item.filterText && item.filterText.toLowerCase().startsWith(currentWord.toLowerCase()))\n    );\n\n    // Sort by relevance\n    return filtered.sort((a, b) => {\n      // Exact matches first\n      const aExact = a.label.toLowerCase() === currentWord.toLowerCase() ? 0 : 1;\n      const bExact = b.label.toLowerCase() === currentWord.toLowerCase() ? 0 : 1;\n      \n      if (aExact !== bExact) return aExact - bExact;\n      \n      // Then by sort text\n      return (a.sortText || a.label).localeCompare(b.sortText || b.label);\n    });\n  }\n\n  private getCurrentWord(context: QueryContext): string {\n    const line = context.text.split('\\n')[context.position.line] || '';\n    const beforeCursor = line.substring(0, context.position.character);\n    const match = beforeCursor.match(/[\\w_]+$/);\n    return match ? match[0] : '';\n  }\n}","import { SchemaInfo, TableInfo, ColumnInfo, FunctionInfo, OperatorInfo, KeywordInfo } from './types';\n\nexport class SchemaProvider {\n  private schema: SchemaInfo;\n\n  constructor() {\n    this.schema = this.initializeSchema();\n  }\n\n  getSchema(): SchemaInfo {\n    return this.schema;\n  }\n\n  getTables(): TableInfo[] {\n    return this.schema.tables;\n  }\n\n  getTable(name: string): TableInfo | undefined {\n    return this.schema.tables.find(t => t.name.toLowerCase() === name.toLowerCase());\n  }\n\n  getColumns(tableName: string): ColumnInfo[] {\n    const table = this.getTable(tableName);\n    return table ? table.columns : [];\n  }\n\n  getColumn(tableName: string, columnName: string): ColumnInfo | undefined {\n    const columns = this.getColumns(tableName);\n    return columns.find(c => c.name.toLowerCase() === columnName.toLowerCase());\n  }\n\n  getFunctions(): FunctionInfo[] {\n    return this.schema.functions;\n  }\n\n  getFunction(name: string): FunctionInfo | undefined {\n    return this.schema.functions.find(f => f.name.toLowerCase() === name.toLowerCase());\n  }\n\n  getOperators(): OperatorInfo[] {\n    return this.schema.operators;\n  }\n\n  getKeywords(): KeywordInfo[] {\n    return this.schema.keywords;\n  }\n\n  private initializeSchema(): SchemaInfo {\n    return {\n      tables: this.initializeTables(),\n      functions: this.initializeFunctions(),\n      operators: this.initializeOperators(),\n      keywords: this.initializeKeywords()\n    };\n  }\n\n  private initializeTables(): TableInfo[] {\n    return [\n      {\n        name: 'logs',\n        description: 'Main table containing all normalized log events',\n        columns: [\n          { name: 'id', type: 'string', description: 'Unique event identifier', nullable: false },\n          { name: 'timestamp', type: 'datetime', description: 'Event timestamp', nullable: false, examples: ['2024-01-01T12:00:00Z'] },\n          { name: 'organization_id', type: 'string', description: 'Organization identifier', nullable: false },\n          { name: 'source_identifier', type: 'string', description: 'Log source identifier', nullable: false, examples: ['macos_auth_events', 'windows_security', 'syslog'] },\n          { name: 'source_type', type: 'string', description: 'Log source type', nullable: false, examples: ['macos-agent', 'windows', 'syslog'] },\n          { name: 'log_level', type: 'string', description: 'Log level', nullable: true, examples: ['INFO', 'WARN', 'ERROR', 'DEBUG'] },\n          { name: 'message', type: 'string', description: 'Event message or description', nullable: true },\n          { name: 'facility', type: 'string', description: 'Syslog facility', nullable: true },\n          { name: 'severity', type: 'int', description: 'Syslog severity level', nullable: true },\n          { name: 'hostname', type: 'string', description: 'Source hostname', nullable: true },\n          { name: 'process_name', type: 'string', description: 'Process name', nullable: true },\n          { name: 'process_id', type: 'int', description: 'Process ID', nullable: true },\n          { name: 'user_name', type: 'string', description: 'Associated username', nullable: true },\n          { name: 'event_id', type: 'string', description: 'Event ID', nullable: true },\n          { name: 'event_category', type: 'string', description: 'Event category', nullable: true, examples: ['authentication', 'network', 'process', 'file'] },\n          { name: 'event_subcategory', type: 'string', description: 'Event subcategory', nullable: true },\n          { name: 'source_ip', type: 'string', description: 'Source IP address', nullable: true },\n          { name: 'destination_ip', type: 'string', description: 'Destination IP address', nullable: true },\n          { name: 'source_port', type: 'int', description: 'Source port', nullable: true },\n          { name: 'destination_port', type: 'int', description: 'Destination port', nullable: true },\n          { name: 'protocol', type: 'string', description: 'Network protocol', nullable: true },\n          { name: 'file_path', type: 'string', description: 'File path', nullable: true },\n          { name: 'file_hash', type: 'string', description: 'File hash', nullable: true },\n          { name: 'auth_user', type: 'string', description: 'Authentication user', nullable: true },\n          { name: 'auth_domain', type: 'string', description: 'Authentication domain', nullable: true },\n          { name: 'auth_method', type: 'string', description: 'Authentication method', nullable: true },\n          { name: 'auth_result', type: 'string', description: 'Authentication result', nullable: true },\n          { name: 'attributes', type: 'dynamic', description: 'Additional event attributes as JSON', nullable: true },\n          { name: 'ingested_at', type: 'datetime', description: 'Ingestion timestamp', nullable: true },\n          { name: 'processed_at', type: 'datetime', description: 'Processing timestamp', nullable: true },\n          { name: 'normalized', type: 'bool', description: 'Whether the log is normalized', nullable: true },\n          { name: 'enriched', type: 'bool', description: 'Whether the log is enriched', nullable: true },\n          { name: 'search_vector', type: 'string', description: 'Full-text search vector', nullable: true }\n        ],\n        sampleQueries: [\n          'logs | where log_level == \"ERROR\"',\n          'logs | where timestamp > ago(1h)',\n          'logs | summarize count() by source_type',\n          'logs | where user_name contains \"admin\"',\n          'logs | where hostname contains \"server\"',\n          'logs | where source_identifier == \"macos_auth_events\"'\n        ]\n      },\n      {\n        name: 'log_events_warm',\n        description: 'Warm tier storage for older log events (8-30 days)',\n        columns: [\n          { name: 'id', type: 'string', description: 'Unique event identifier', nullable: false },\n          { name: 'timestamp', type: 'datetime', description: 'Event timestamp', nullable: false },\n          { name: 'organization_id', type: 'string', description: 'Organization identifier', nullable: false },\n          { name: 'source', type: 'string', description: 'Log source system', nullable: false },\n          { name: 'severity', type: 'string', description: 'Event severity level', nullable: false },\n          { name: 'category', type: 'string', description: 'Event category', nullable: false },\n          { name: 'message', type: 'string', description: 'Event message or description', nullable: true },\n          { name: 'event_data', type: 'dynamic', description: 'Additional event data as JSON', nullable: true },\n          { name: 'risk_score', type: 'int', description: 'Risk score (0-100)', nullable: true }\n        ]\n      },\n      {\n        name: 'log_events_cold',\n        description: 'Cold tier storage for archived log events (31-90 days)',\n        columns: [\n          { name: 'id', type: 'string', description: 'Unique event identifier', nullable: false },\n          { name: 'timestamp', type: 'datetime', description: 'Event timestamp', nullable: false },\n          { name: 'organization_id', type: 'string', description: 'Organization identifier', nullable: false },\n          { name: 'source', type: 'string', description: 'Log source system', nullable: false },\n          { name: 'severity', type: 'string', description: 'Event severity level', nullable: false },\n          { name: 'category', type: 'string', description: 'Event category', nullable: false },\n          { name: 'message', type: 'string', description: 'Event message or description', nullable: true },\n          { name: 'event_data', type: 'dynamic', description: 'Additional event data as JSON', nullable: true },\n          { name: 'risk_score', type: 'int', description: 'Risk score (0-100)', nullable: true }\n        ]\n      },\n      {\n        name: 'log_events_hourly',\n        description: 'Hourly aggregated view of log events',\n        columns: [\n          { name: 'hour', type: 'datetime', description: 'Hour bucket', nullable: false },\n          { name: 'organization_id', type: 'string', description: 'Organization identifier', nullable: false },\n          { name: 'source', type: 'string', description: 'Log source system', nullable: false },\n          { name: 'severity', type: 'string', description: 'Event severity level', nullable: false },\n          { name: 'category', type: 'string', description: 'Event category', nullable: false },\n          { name: 'event_count', type: 'long', description: 'Number of events in the hour', nullable: false },\n          { name: 'avg_risk_score', type: 'real', description: 'Average risk score', nullable: true },\n          { name: 'max_risk_score', type: 'int', description: 'Maximum risk score', nullable: true },\n          { name: 'unique_hosts', type: 'long', description: 'Number of unique hosts', nullable: false },\n          { name: 'unique_users', type: 'long', description: 'Number of unique users', nullable: false }\n        ]\n      },\n      {\n        name: 'log_events_daily',\n        description: 'Daily aggregated view of log events',\n        columns: [\n          { name: 'day', type: 'datetime', description: 'Day bucket', nullable: false },\n          { name: 'organization_id', type: 'string', description: 'Organization identifier', nullable: false },\n          { name: 'source', type: 'string', description: 'Log source system', nullable: false },\n          { name: 'severity', type: 'string', description: 'Event severity level', nullable: false },\n          { name: 'category', type: 'string', description: 'Event category', nullable: false },\n          { name: 'event_count', type: 'long', description: 'Number of events in the day', nullable: false },\n          { name: 'avg_risk_score', type: 'real', description: 'Average risk score', nullable: true },\n          { name: 'max_risk_score', type: 'int', description: 'Maximum risk score', nullable: true },\n          { name: 'unique_hosts', type: 'long', description: 'Number of unique hosts', nullable: false },\n          { name: 'unique_users', type: 'long', description: 'Number of unique users', nullable: false },\n          { name: 'severity_breakdown', type: 'dynamic', description: 'Breakdown by severity', nullable: true }\n        ]\n      }\n    ];\n  }\n\n  private initializeFunctions(): FunctionInfo[] {\n    return [\n      // Aggregation functions\n      {\n        name: 'count',\n        description: 'Returns the number of records in the group',\n        parameters: [\n          { name: 'expression', type: 'any', optional: true, description: 'Expression to count (optional)' }\n        ],\n        returnType: 'long',\n        category: 'aggregation',\n        examples: ['count()', 'count(user_name)']\n      },\n      {\n        name: 'sum',\n        description: 'Returns the sum of the expression across the group',\n        parameters: [\n          { name: 'expression', type: 'numeric', optional: false, description: 'Numeric expression to sum' }\n        ],\n        returnType: 'numeric',\n        category: 'aggregation',\n        examples: ['sum(risk_score)', 'sum(event_data.bytes)']\n      },\n      {\n        name: 'avg',\n        description: 'Returns the average value of the expression across the group',\n        parameters: [\n          { name: 'expression', type: 'numeric', optional: false, description: 'Numeric expression to average' }\n        ],\n        returnType: 'real',\n        category: 'aggregation',\n        examples: ['avg(risk_score)', 'avg(event_data.duration)']\n      },\n      {\n        name: 'min',\n        description: 'Returns the minimum value of the expression across the group',\n        parameters: [\n          { name: 'expression', type: 'any', optional: false, description: 'Expression to find minimum' }\n        ],\n        returnType: 'any',\n        category: 'aggregation',\n        examples: ['min(timestamp)', 'min(risk_score)']\n      },\n      {\n        name: 'max',\n        description: 'Returns the maximum value of the expression across the group',\n        parameters: [\n          { name: 'expression', type: 'any', optional: false, description: 'Expression to find maximum' }\n        ],\n        returnType: 'any',\n        category: 'aggregation',\n        examples: ['max(timestamp)', 'max(risk_score)']\n      },\n      {\n        name: 'dcount',\n        description: 'Returns the number of distinct values of the expression',\n        parameters: [\n          { name: 'expression', type: 'any', optional: false, description: 'Expression to count distinct values' }\n        ],\n        returnType: 'long',\n        category: 'aggregation',\n        examples: ['dcount(user_name)', 'dcount(host_ip)']\n      },\n      \n      // Scalar functions\n      {\n        name: 'ago',\n        description: 'Returns the time duration before the current UTC time',\n        parameters: [\n          { name: 'timespan', type: 'timespan', optional: false, description: 'Time duration to subtract' }\n        ],\n        returnType: 'datetime',\n        category: 'scalar',\n        examples: ['ago(1h)', 'ago(7d)', 'ago(30m)']\n      },\n      {\n        name: 'now',\n        description: 'Returns the current UTC time',\n        parameters: [],\n        returnType: 'datetime',\n        category: 'scalar',\n        examples: ['now()']\n      },\n      {\n        name: 'strlen',\n        description: 'Returns the length of the string',\n        parameters: [\n          { name: 'string', type: 'string', optional: false, description: 'Input string' }\n        ],\n        returnType: 'int',\n        category: 'scalar',\n        examples: ['strlen(message)', 'strlen(user_name)']\n      },\n      {\n        name: 'substring',\n        description: 'Returns a substring starting at the specified index',\n        parameters: [\n          { name: 'string', type: 'string', optional: false, description: 'Input string' },\n          { name: 'start', type: 'int', optional: false, description: 'Start index (0-based)' },\n          { name: 'length', type: 'int', optional: true, description: 'Length of substring' }\n        ],\n        returnType: 'string',\n        category: 'scalar',\n        examples: ['substring(message, 0, 10)', 'substring(host_name, 3)']\n      },\n      {\n        name: 'toupper',\n        description: 'Converts string to uppercase',\n        parameters: [\n          { name: 'string', type: 'string', optional: false, description: 'Input string' }\n        ],\n        returnType: 'string',\n        category: 'scalar',\n        examples: ['toupper(user_name)', 'toupper(source)']\n      },\n      {\n        name: 'tolower',\n        description: 'Converts string to lowercase',\n        parameters: [\n          { name: 'string', type: 'string', optional: false, description: 'Input string' }\n        ],\n        returnType: 'string',\n        category: 'scalar',\n        examples: ['tolower(user_name)', 'tolower(message)']\n      },\n      {\n        name: 'replace',\n        description: 'Replaces all occurrences of a substring with another string',\n        parameters: [\n          { name: 'string', type: 'string', optional: false, description: 'Input string' },\n          { name: 'pattern', type: 'string', optional: false, description: 'Pattern to replace' },\n          { name: 'replacement', type: 'string', optional: false, description: 'Replacement string' }\n        ],\n        returnType: 'string',\n        category: 'scalar',\n        examples: ['replace(message, \"error\", \"ERROR\")', 'replace(host_name, \".local\", \"\")']\n      },\n      {\n        name: 'split',\n        description: 'Splits a string by a delimiter and returns an array',\n        parameters: [\n          { name: 'string', type: 'string', optional: false, description: 'Input string' },\n          { name: 'delimiter', type: 'string', optional: false, description: 'Delimiter string' }\n        ],\n        returnType: 'dynamic',\n        category: 'scalar',\n        examples: ['split(host_name, \".\")', 'split(message, \" \")']\n      },\n      {\n        name: 'trim',\n        description: 'Removes leading and trailing whitespace',\n        parameters: [\n          { name: 'string', type: 'string', optional: false, description: 'Input string' }\n        ],\n        returnType: 'string',\n        category: 'scalar',\n        examples: ['trim(message)', 'trim(user_name)']\n      },\n      {\n        name: 'isempty',\n        description: 'Returns true if the string is empty or null',\n        parameters: [\n          { name: 'string', type: 'string', optional: false, description: 'Input string' }\n        ],\n        returnType: 'bool',\n        category: 'scalar',\n        examples: ['isempty(user_name)', 'isempty(message)']\n      },\n      {\n        name: 'isnull',\n        description: 'Returns true if the expression is null',\n        parameters: [\n          { name: 'expression', type: 'any', optional: false, description: 'Expression to check' }\n        ],\n        returnType: 'bool',\n        category: 'scalar',\n        examples: ['isnull(user_name)', 'isnull(event_data.field)']\n      },\n      {\n        name: 'coalesce',\n        description: 'Returns the first non-null expression',\n        parameters: [\n          { name: 'expression1', type: 'any', optional: false, description: 'First expression' },\n          { name: 'expression2', type: 'any', optional: false, description: 'Second expression' }\n        ],\n        returnType: 'any',\n        category: 'scalar',\n        examples: ['coalesce(user_name, \"unknown\")', 'coalesce(event_data.user, user_name)']\n      }\n    ];\n  }\n\n  private initializeOperators(): OperatorInfo[] {\n    return [\n      {\n        operator: '==',\n        description: 'Equals comparison',\n        leftType: 'any',\n        rightType: 'any',\n        returnType: 'bool',\n        examples: ['severity == \"critical\"', 'risk_score == 100']\n      },\n      {\n        operator: '!=',\n        description: 'Not equals comparison',\n        leftType: 'any',\n        rightType: 'any',\n        returnType: 'bool',\n        examples: ['severity != \"info\"', 'user_name != \"\"']\n      },\n      {\n        operator: '<',\n        description: 'Less than comparison',\n        leftType: 'numeric',\n        rightType: 'numeric',\n        returnType: 'bool',\n        examples: ['risk_score < 50', 'timestamp < ago(1h)']\n      },\n      {\n        operator: '<=',\n        description: 'Less than or equal comparison',\n        leftType: 'numeric',\n        rightType: 'numeric',\n        returnType: 'bool',\n        examples: ['risk_score <= 75', 'timestamp <= now()']\n      },\n      {\n        operator: '>',\n        description: 'Greater than comparison',\n        leftType: 'numeric',\n        rightType: 'numeric',\n        returnType: 'bool',\n        examples: ['risk_score > 80', 'timestamp > ago(24h)']\n      },\n      {\n        operator: '>=',\n        description: 'Greater than or equal comparison',\n        leftType: 'numeric',\n        rightType: 'numeric',\n        returnType: 'bool',\n        examples: ['risk_score >= 90', 'timestamp >= ago(1d)']\n      },\n      {\n        operator: 'contains',\n        description: 'String contains substring (case-insensitive)',\n        leftType: 'string',\n        rightType: 'string',\n        returnType: 'bool',\n        examples: ['message contains \"error\"', 'user_name contains \"admin\"']\n      },\n      {\n        operator: '!contains',\n        description: 'String does not contain substring (case-insensitive)',\n        leftType: 'string',\n        rightType: 'string',\n        returnType: 'bool',\n        examples: ['message !contains \"debug\"', 'host_name !contains \"test\"']\n      },\n      {\n        operator: 'startswith',\n        description: 'String starts with substring (case-insensitive)',\n        leftType: 'string',\n        rightType: 'string',\n        returnType: 'bool',\n        examples: ['user_name startswith \"admin\"', 'host_name startswith \"web\"']\n      },\n      {\n        operator: 'endswith',\n        description: 'String ends with substring (case-insensitive)',\n        leftType: 'string',\n        rightType: 'string',\n        returnType: 'bool',\n        examples: ['host_name endswith \".com\"', 'message endswith \"failed\"']\n      },\n      {\n        operator: 'matches',\n        description: 'String matches regular expression',\n        leftType: 'string',\n        rightType: 'string',\n        returnType: 'bool',\n        examples: ['host_ip matches @\"\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+\"', 'user_name matches @\"[a-zA-Z]+\"']\n      },\n      {\n        operator: 'in',\n        description: 'Value is in a list of values',\n        leftType: 'any',\n        rightType: 'array',\n        returnType: 'bool',\n        examples: ['severity in (\"critical\", \"high\")', 'source in (\"Windows\", \"Linux\")']\n      },\n      {\n        operator: '!in',\n        description: 'Value is not in a list of values',\n        leftType: 'any',\n        rightType: 'array',\n        returnType: 'bool',\n        examples: ['severity !in (\"info\", \"debug\")', 'user_name !in (\"guest\", \"anonymous\")']\n      },\n      {\n        operator: 'between',\n        description: 'Value is between two values (inclusive)',\n        leftType: 'numeric',\n        rightType: 'numeric',\n        returnType: 'bool',\n        examples: ['risk_score between (50 .. 90)', 'timestamp between (ago(2h) .. ago(1h))']\n      },\n      {\n        operator: 'and',\n        description: 'Logical AND operation',\n        leftType: 'bool',\n        rightType: 'bool',\n        returnType: 'bool',\n        examples: ['severity == \"critical\" and risk_score > 80', 'timestamp > ago(1h) and user_name != \"\"']\n      },\n      {\n        operator: 'or',\n        description: 'Logical OR operation',\n        leftType: 'bool',\n        rightType: 'bool',\n        returnType: 'bool',\n        examples: ['severity == \"critical\" or risk_score > 90', 'source == \"Windows\" or source == \"Linux\"']\n      },\n      {\n        operator: 'not',\n        description: 'Logical NOT operation',\n        leftType: 'bool',\n        rightType: '',\n        returnType: 'bool',\n        examples: ['not (severity == \"info\")', 'not isempty(user_name)']\n      }\n    ];\n  }\n\n  private initializeKeywords(): KeywordInfo[] {\n    return [\n      {\n        keyword: 'where',\n        description: 'Filters rows based on a predicate',\n        category: 'command',\n        examples: ['| where severity == \"critical\"', '| where timestamp > ago(1h)']\n      },\n      {\n        keyword: 'project',\n        description: 'Selects specific columns to include in the output',\n        category: 'command',\n        examples: ['| project timestamp, severity, message', '| project user_name, risk_score']\n      },\n      {\n        keyword: 'extend',\n        description: 'Adds computed columns to the result set',\n        category: 'command',\n        examples: ['| extend hour = bin(timestamp, 1h)', '| extend is_admin = user_name contains \"admin\"']\n      },\n      {\n        keyword: 'summarize',\n        description: 'Aggregates data by grouping and applying aggregation functions',\n        category: 'command',\n        examples: ['| summarize count() by severity', '| summarize avg(risk_score) by source']\n      },\n      {\n        keyword: 'order',\n        description: 'Sorts the result set by one or more columns',\n        category: 'command',\n        examples: ['| order by timestamp desc', '| order by risk_score desc, timestamp asc']\n      },\n      {\n        keyword: 'top',\n        description: 'Returns the top N rows, optionally ordered by specific columns',\n        category: 'command',\n        examples: ['| top 10 by risk_score desc', '| top 100 by timestamp desc']\n      },\n      {\n        keyword: 'limit',\n        description: 'Limits the number of rows returned',\n        category: 'command',\n        examples: ['| limit 1000', '| limit 50']\n      },\n      {\n        keyword: 'distinct',\n        description: 'Returns unique rows or unique values for specified columns',\n        category: 'command',\n        examples: ['| distinct user_name', '| distinct source, severity']\n      },\n      {\n        keyword: 'join',\n        description: 'Joins two tables based on matching columns',\n        category: 'command',\n        examples: ['| join kind=inner other_table on user_name', '| join kind=left users on $left.user_name == $right.name']\n      },\n      {\n        keyword: 'union',\n        description: 'Combines the results of multiple tables',\n        category: 'command',\n        examples: ['| union log_events_warm, log_events_cold', '| union table1, table2']\n      },\n      {\n        keyword: 'let',\n        description: 'Binds a name to an expression for reuse in the query',\n        category: 'command',\n        examples: ['let timeRange = ago(1h);', 'let criticalEvents = log_events | where severity == \"critical\";']\n      },\n      {\n        keyword: 'by',\n        description: 'Specifies grouping columns in summarize operations',\n        category: 'function',\n        examples: ['summarize count() by source', 'summarize avg(risk_score) by severity, source']\n      },\n      {\n        keyword: 'asc',\n        description: 'Ascending sort order',\n        category: 'function',\n        examples: ['order by timestamp asc', 'top 10 by risk_score asc']\n      },\n      {\n        keyword: 'desc',\n        description: 'Descending sort order',\n        category: 'function',\n        examples: ['order by timestamp desc', 'top 10 by risk_score desc']\n      }\n    ];\n  }\n}","import { Pool } from 'pg';\nimport { QueryExecutor } from './execution/query-executor';\nimport { CompletionProvider } from './intellisense/completion-provider';\nimport { SchemaProvider } from './intellisense/schema-provider';\nimport { KQLLexer } from './lexer/lexer';\nimport { KQLParser } from './parser/parser';\nimport { ExecutionContext, QueryResult, CompletionItem, Position, CompletionContext } from './index';\n\nexport interface KQLEngineConfig {\n  database: Pool;\n  cache?: {\n    enabled: boolean;\n    maxSize?: number;\n    ttl?: number;\n  };\n  timeout?: number;\n  maxRows?: number;\n}\n\nexport class KQLEngine {\n  private queryExecutor: QueryExecutor;\n  private completionProvider: CompletionProvider;\n  private schemaProvider: SchemaProvider;\n\n  constructor(config: KQLEngineConfig) {\n    this.schemaProvider = new SchemaProvider();\n    this.queryExecutor = new QueryExecutor(\n      config.database,\n      config.cache?.enabled ? {\n        max: config.cache.maxSize || 1000,\n        ttl: config.cache.ttl || 5 * 60 * 1000\n      } : undefined\n    );\n    this.completionProvider = new CompletionProvider(this.schemaProvider);\n  }\n\n  // Query execution methods\n  async executeQuery(kqlQuery: string, context: ExecutionContext): Promise<QueryResult> {\n    return this.queryExecutor.executeKQL(kqlQuery, context);\n  }\n\n  async explainQuery(kqlQuery: string, context: ExecutionContext) {\n    return this.queryExecutor.explainKQL(kqlQuery, context);\n  }\n\n  async validateQuery(kqlQuery: string): Promise<{ valid: boolean; errors: string[] }> {\n    return this.queryExecutor.validateKQL(kqlQuery);\n  }\n\n  // IntelliSense methods\n  async getCompletions(\n    text: string,\n    position: Position,\n    context?: CompletionContext\n  ): Promise<CompletionItem[]> {\n    return this.completionProvider.provideCompletions(text, position, context);\n  }\n\n  // Schema methods\n  getTableSchemas() {\n    return this.schemaProvider.getSchema();\n  }\n\n  getTables() {\n    return this.schemaProvider.getTables();\n  }\n\n  getTable(name: string) {\n    return this.schemaProvider.getTable(name);\n  }\n\n  getColumns(tableName: string) {\n    return this.schemaProvider.getColumns(tableName);\n  }\n\n  getFunctions() {\n    return this.schemaProvider.getFunctions();\n  }\n\n  // Utility methods\n  tokenize(kqlQuery: string) {\n    const lexer = new KQLLexer(kqlQuery);\n    return lexer.tokenize();\n  }\n\n  parse(kqlQuery: string) {\n    const lexer = new KQLLexer(kqlQuery);\n    const { tokens, errors: lexErrors } = lexer.tokenize();\n    \n    if (lexErrors.length > 0) {\n      return { query: null, errors: lexErrors.map(e => e.message) };\n    }\n\n    const parser = new KQLParser(tokens);\n    const { query, errors: parseErrors } = parser.parse();\n    \n    return { \n      query, \n      errors: parseErrors.map(e => e.message) \n    };\n  }\n\n  // Performance and monitoring\n  getCacheStats() {\n    return this.queryExecutor.getCacheStats();\n  }\n\n  clearCache() {\n    this.queryExecutor.clearCache();\n  }\n\n  async getDbSchemas(organizationId: string) {\n    return this.queryExecutor.getTableSchemas(organizationId);\n  }\n}","export interface SecurityTemplate {\n  id: string;\n  name: string;\n  description: string;\n  category: SecurityCategory;\n  query: string;\n  parameters?: TemplateParameter[];\n  tags: string[];\n  mitreTactics?: string[];\n  mitreAttackIds?: string[];\n  difficulty: 'beginner' | 'intermediate' | 'advanced';\n  useCase: string;\n}\n\nexport interface TemplateParameter {\n  name: string;\n  type: 'string' | 'number' | 'timespan' | 'datetime' | 'boolean';\n  description: string;\n  defaultValue?: any;\n  required: boolean;\n  options?: any[];\n}\n\nexport enum SecurityCategory {\n  AUTHENTICATION = 'Authentication',\n  NETWORK_SECURITY = 'Network Security',\n  MALWARE_DETECTION = 'Malware Detection',\n  DATA_EXFILTRATION = 'Data Exfiltration',\n  PRIVILEGE_ESCALATION = 'Privilege Escalation',\n  LATERAL_MOVEMENT = 'Lateral Movement',\n  PERSISTENCE = 'Persistence',\n  RECONNAISSANCE = 'Reconnaissance',\n  THREAT_HUNTING = 'Threat Hunting',\n  COMPLIANCE = 'Compliance',\n  INCIDENT_RESPONSE = 'Incident Response',\n  ANOMALY_DETECTION = 'Anomaly Detection'\n}\n\nexport const SECURITY_TEMPLATES: SecurityTemplate[] = [\n  {\n    id: 'failed-logins-high-volume',\n    name: 'High Volume Failed Login Attempts',\n    description: 'Detect accounts with an unusually high number of failed login attempts within a time window',\n    category: SecurityCategory.AUTHENTICATION,\n    query: `log_events\n| where timestamp > ago({timeRange})\n| where category == \"authentication\" \n| where severity in (\"medium\", \"high\", \"critical\")\n| where message contains \"failed\" or message contains \"denied\"\n| summarize FailedAttempts = count(), \n           DistinctSources = dcount(host_ip),\n           FirstAttempt = min(timestamp),\n           LastAttempt = max(timestamp)\n    by user_name\n| where FailedAttempts > {threshold}\n| order by FailedAttempts desc`,\n    parameters: [\n      {\n        name: 'timeRange',\n        type: 'timespan',\n        description: 'Time window to analyze',\n        defaultValue: '1h',\n        required: true,\n        options: ['15m', '30m', '1h', '6h', '24h']\n      },\n      {\n        name: 'threshold',\n        type: 'number',\n        description: 'Minimum number of failed attempts to alert on',\n        defaultValue: 10,\n        required: true\n      }\n    ],\n    tags: ['brute-force', 'authentication', 'security-monitoring'],\n    mitreTactics: ['Credential Access'],\n    mitreAttackIds: ['T1110'],\n    difficulty: 'beginner',\n    useCase: 'Identify potential brute force attacks against user accounts'\n  },\n  \n  {\n    id: 'suspicious-network-connections',\n    name: 'Suspicious Outbound Network Connections',\n    description: 'Detect unusual outbound network connections to suspicious domains or IP ranges',\n    category: SecurityCategory.NETWORK_SECURITY,\n    query: `log_events\n| where timestamp > ago({timeRange})\n| where category == \"network\"\n| where event_data.direction == \"outbound\"\n| where event_data.destination_ip !startswith \"10.\"\n    and event_data.destination_ip !startswith \"192.168.\"\n    and event_data.destination_ip !startswith \"172.16.\"\n| summarize ConnectionCount = count(),\n           DistinctPorts = dcount(event_data.destination_port),\n           Ports = make_set(event_data.destination_port),\n           BytesTransferred = sum(event_data.bytes)\n    by host_name, event_data.destination_ip, event_data.destination_domain\n| where ConnectionCount > {connectionThreshold} or BytesTransferred > {bytesThreshold}\n| extend RiskScore = case(\n    BytesTransferred > 1000000, 90,\n    ConnectionCount > 100, 80,\n    DistinctPorts > 10, 70,\n    60\n)\n| order by RiskScore desc, BytesTransferred desc`,\n    parameters: [\n      {\n        name: 'timeRange',\n        type: 'timespan',\n        description: 'Time window to analyze',\n        defaultValue: '1h',\n        required: true\n      },\n      {\n        name: 'connectionThreshold',\n        type: 'number',\n        description: 'Minimum connection count to alert on',\n        defaultValue: 50,\n        required: true\n      },\n      {\n        name: 'bytesThreshold',\n        type: 'number',\n        description: 'Minimum bytes transferred to alert on',\n        defaultValue: 100000,\n        required: true\n      }\n    ],\n    tags: ['network', 'data-exfiltration', 'c2-communication'],\n    mitreTactics: ['Command and Control', 'Exfiltration'],\n    mitreAttackIds: ['T1041', 'T1071'],\n    difficulty: 'intermediate',\n    useCase: 'Detect potential data exfiltration or command and control communications'\n  },\n\n  {\n    id: 'privilege-escalation-detection',\n    name: 'Privilege Escalation Attempts',\n    description: 'Identify attempts to escalate privileges or access sensitive resources',\n    category: SecurityCategory.PRIVILEGE_ESCALATION,\n    query: `log_events\n| where timestamp > ago({timeRange})\n| where category in (\"authentication\", \"process\", \"file\")\n| where message contains \"privilege\" \n    or message contains \"admin\" \n    or message contains \"root\"\n    or message contains \"escalation\"\n    or event_data.process_name in (\"sudo\", \"su\", \"runas\", \"psexec\")\n| extend IsHighPrivilegeProcess = event_data.process_name in (\"sudo\", \"su\", \"runas\", \"psexec\", \"cmd.exe\", \"powershell.exe\")\n| extend IsAdminUser = user_name contains \"admin\" or user_name contains \"root\"\n| extend IsSuspiciousTime = hourofday(timestamp) < 6 or hourofday(timestamp) > 22\n| summarize EventCount = count(),\n           DistinctProcesses = dcount(event_data.process_name),\n           Processes = make_set(event_data.process_name),\n           FirstEvent = min(timestamp),\n           LastEvent = max(timestamp),\n           HighPrivilegeEvents = countif(IsHighPrivilegeProcess),\n           SuspiciousTimeEvents = countif(IsSuspiciousTime)\n    by user_name, host_name\n| extend RiskScore = case(\n    HighPrivilegeEvents > 10 and SuspiciousTimeEvents > 5, 95,\n    HighPrivilegeEvents > 5, 80,\n    EventCount > 20, 70,\n    50\n)\n| where RiskScore >= {riskThreshold}\n| order by RiskScore desc, EventCount desc`,\n    parameters: [\n      {\n        name: 'timeRange',\n        type: 'timespan',\n        description: 'Time window to analyze',\n        defaultValue: '6h',\n        required: true\n      },\n      {\n        name: 'riskThreshold',\n        type: 'number',\n        description: 'Minimum risk score to alert on (0-100)',\n        defaultValue: 70,\n        required: true\n      }\n    ],\n    tags: ['privilege-escalation', 'process-monitoring', 'insider-threat'],\n    mitreTactics: ['Privilege Escalation', 'Defense Evasion'],\n    mitreAttackIds: ['T1068', 'T1134', 'T1548'],\n    difficulty: 'advanced',\n    useCase: 'Detect unauthorized attempts to gain elevated privileges'\n  },\n\n  {\n    id: 'malware-process-indicators',\n    name: 'Malware Process Indicators',\n    description: 'Detect processes with characteristics commonly associated with malware',\n    category: SecurityCategory.MALWARE_DETECTION,\n    query: `log_events\n| where timestamp > ago({timeRange})\n| where category == \"process\"\n| where event_data.action in (\"created\", \"started\")\n| extend ProcessPath = tolower(event_data.process_path)\n| extend ProcessName = tolower(event_data.process_name)\n| extend IsSuspiciousLocation = ProcessPath contains \"temp\" \n    or ProcessPath contains \"downloads\" \n    or ProcessPath contains \"appdata\\\\\\\\local\\\\\\\\temp\"\n    or ProcessPath contains \"recycle\"\n| extend HasSuspiciousName = ProcessName matches regex @\"^[a-f0-9]{8,}\\\\\\\\.(exe|dll|scr)$\"\n    or ProcessName contains \"svchost\" and not ProcessPath contains \"system32\"\n    or ProcessName contains \"rundll32\" and event_data.command_line contains \".tmp\"\n| extend IsUnsignedBinary = event_data.signed == false or isnull(event_data.signature)\n| extend HasSuspiciousCommandLine = event_data.command_line contains \"powershell -enc\"\n    or event_data.command_line contains \"cmd /c echo\"\n    or event_data.command_line contains \"wscript\"\n    or event_data.command_line contains \"cscript\"\n| extend RiskIndicators = toint(IsSuspiciousLocation) + toint(HasSuspiciousName) + \n                         toint(IsUnsignedBinary) + toint(HasSuspiciousCommandLine)\n| where RiskIndicators >= {indicatorThreshold}\n| summarize ProcessCount = count(),\n           DistinctHosts = dcount(host_name),\n           Hosts = make_set(host_name),\n           FirstSeen = min(timestamp),\n           LastSeen = max(timestamp)\n    by ProcessName, event_data.process_path, event_data.parent_process, RiskIndicators\n| extend RiskScore = case(\n    RiskIndicators >= 3, 90,\n    RiskIndicators >= 2, 75,\n    60\n)\n| order by RiskScore desc, ProcessCount desc`,\n    parameters: [\n      {\n        name: 'timeRange',\n        type: 'timespan',\n        description: 'Time window to analyze',\n        defaultValue: '24h',\n        required: true\n      },\n      {\n        name: 'indicatorThreshold',\n        type: 'number',\n        description: 'Minimum number of risk indicators to alert on',\n        defaultValue: 2,\n        required: true,\n        options: [1, 2, 3, 4]\n      }\n    ],\n    tags: ['malware', 'process-analysis', 'threat-hunting'],\n    mitreTactics: ['Execution', 'Defense Evasion'],\n    mitreAttackIds: ['T1055', 'T1036', 'T1027'],\n    difficulty: 'advanced',\n    useCase: 'Identify potentially malicious processes based on behavioral indicators'\n  },\n\n  {\n    id: 'data-exfiltration-patterns',\n    name: 'Data Exfiltration Patterns',\n    description: 'Detect patterns indicative of large-scale data theft or unauthorized data movement',\n    category: SecurityCategory.DATA_EXFILTRATION,\n    query: `log_events\n| where timestamp > ago({timeRange})\n| where category in (\"file\", \"network\")\n| where event_data.action in (\"read\", \"copy\", \"upload\", \"transfer\", \"download\")\n| extend FileSize = tolong(event_data.file_size)\n| extend IsLargeFile = FileSize > {fileSizeThreshold}\n| extend IsSensitiveFile = event_data.file_path contains \"confidential\"\n    or event_data.file_path contains \"secret\"\n    or event_data.file_extension in (\".xlsx\", \".docx\", \".pdf\", \".sql\", \".csv\")\n| extend IsExternalTransfer = event_data.destination_ip !startswith \"10.\"\n    and event_data.destination_ip !startswith \"192.168.\"\n    and event_data.destination_ip !startswith \"172.16.\"\n| summarize TotalFiles = count(),\n           TotalBytes = sum(FileSize),\n           LargeFiles = countif(IsLargeFile),\n           SensitiveFiles = countif(IsSensitiveFile),\n           ExternalTransfers = countif(IsExternalTransfer),\n           DistinctDestinations = dcount(event_data.destination_ip),\n           FilePaths = make_set(event_data.file_path, 20)\n    by user_name, host_name, bin(timestamp, {timeBin})\n| extend DataVolumeMB = TotalBytes / (1024 * 1024)\n| extend RiskScore = case(\n    DataVolumeMB > 1000 and ExternalTransfers > 0, 95,\n    SensitiveFiles > 10 and ExternalTransfers > 0, 90,\n    DataVolumeMB > 500, 80,\n    LargeFiles > 20, 70,\n    50\n)\n| where RiskScore >= {riskThreshold}\n| order by RiskScore desc, DataVolumeMB desc`,\n    parameters: [\n      {\n        name: 'timeRange',\n        type: 'timespan',\n        description: 'Time window to analyze',\n        defaultValue: '6h',\n        required: true\n      },\n      {\n        name: 'fileSizeThreshold',\n        type: 'number',\n        description: 'File size threshold in bytes for large files',\n        defaultValue: 10485760,\n        required: true\n      },\n      {\n        name: 'timeBin',\n        type: 'timespan',\n        description: 'Time bin for aggregation',\n        defaultValue: '1h',\n        required: true,\n        options: ['15m', '30m', '1h', '2h']\n      },\n      {\n        name: 'riskThreshold',\n        type: 'number',\n        description: 'Minimum risk score to alert on',\n        defaultValue: 70,\n        required: true\n      }\n    ],\n    tags: ['data-exfiltration', 'file-monitoring', 'insider-threat'],\n    mitreTactics: ['Collection', 'Exfiltration'],\n    mitreAttackIds: ['T1005', 'T1041', 'T1052'],\n    difficulty: 'intermediate',\n    useCase: 'Detect unauthorized movement of sensitive data'\n  },\n\n  {\n    id: 'lateral-movement-detection',\n    name: 'Lateral Movement Detection',\n    description: 'Identify attempts to move laterally through the network using compromised credentials',\n    category: SecurityCategory.LATERAL_MOVEMENT,\n    query: `log_events\n| where timestamp > ago({timeRange})\n| where category in (\"authentication\", \"network\", \"process\")\n| where event_data.action in (\"logon\", \"connect\", \"execute_remote\")\n| extend SourceHost = coalesce(event_data.source_host, host_name)\n| extend TargetHost = coalesce(event_data.target_host, event_data.destination_host)\n| extend IsRemoteAccess = isnotnull(TargetHost) and SourceHost != TargetHost\n| extend IsAdminLogin = user_name contains \"admin\" or event_data.logon_type in (\"2\", \"10\")\n| extend IsSuspiciousService = event_data.service_name in (\"psexec\", \"wmi\", \"winrm\", \"rdp\", \"ssh\")\n| where IsRemoteAccess\n| summarize RemoteConnections = count(),\n           DistinctTargets = dcount(TargetHost),\n           DistinctSources = dcount(SourceHost),\n           Targets = make_set(TargetHost),\n           Sources = make_set(SourceHost),\n           AdminLogins = countif(IsAdminLogin),\n           SuspiciousServices = countif(IsSuspiciousService),\n           FirstConnection = min(timestamp),\n           LastConnection = max(timestamp)\n    by user_name\n| extend ConnectionVelocity = RemoteConnections / (datetime_diff('minute', LastConnection, FirstConnection) + 1)\n| extend RiskScore = case(\n    DistinctTargets > 10 and AdminLogins > 5, 95,\n    ConnectionVelocity > 5 and DistinctTargets > 5, 90,\n    SuspiciousServices > 0 and DistinctTargets > 3, 85,\n    DistinctTargets > 5, 75,\n    50\n)\n| where RiskScore >= {riskThreshold}\n| order by RiskScore desc, DistinctTargets desc`,\n    parameters: [\n      {\n        name: 'timeRange',\n        type: 'timespan',\n        description: 'Time window to analyze',\n        defaultValue: '4h',\n        required: true\n      },\n      {\n        name: 'riskThreshold',\n        type: 'number',\n        description: 'Minimum risk score to alert on',\n        defaultValue: 75,\n        required: true\n      }\n    ],\n    tags: ['lateral-movement', 'network-analysis', 'threat-hunting'],\n    mitreTactics: ['Lateral Movement'],\n    mitreAttackIds: ['T1021', 'T1047', 'T1028'],\n    difficulty: 'advanced',\n    useCase: 'Detect attackers moving laterally through the network'\n  },\n\n  {\n    id: 'anomalous-user-behavior',\n    name: 'Anomalous User Behavior Detection',\n    description: 'Identify users exhibiting unusual behavior patterns that may indicate compromise',\n    category: SecurityCategory.ANOMALY_DETECTION,\n    query: `let UserBaseline = log_events\n| where timestamp between (ago({baselineWindow}) .. ago({timeRange}))\n| where category in (\"authentication\", \"file\", \"process\", \"network\")\n| summarize BaselineLogins = dcount(host_name),\n           BaselineProcesses = dcount(event_data.process_name),\n           BaselineFiles = dcount(event_data.file_path),\n           BaselineHours = dcount(hourofday(timestamp))\n    by user_name;\nlog_events\n| where timestamp > ago({timeRange})\n| where category in (\"authentication\", \"file\", \"process\", \"network\")\n| summarize CurrentLogins = dcount(host_name),\n           CurrentProcesses = dcount(event_data.process_name),\n           CurrentFiles = dcount(event_data.file_path),\n           CurrentHours = dcount(hourofday(timestamp)),\n           TotalEvents = count(),\n           OffHoursEvents = countif(hourofday(timestamp) < 6 or hourofday(timestamp) > 22),\n           WeekendEvents = countif(dayofweek(timestamp) in (0, 6))\n    by user_name\n| join kind=inner UserBaseline on user_name\n| extend LoginAnomaly = todouble(CurrentLogins) / (BaselineLogins + 1)\n| extend ProcessAnomaly = todouble(CurrentProcesses) / (BaselineProcesses + 1)\n| extend FileAnomaly = todouble(CurrentFiles) / (BaselineFiles + 1)\n| extend TimeAnomaly = todouble(CurrentHours) / (BaselineHours + 1)\n| extend OffHoursRatio = todouble(OffHoursEvents) / TotalEvents\n| extend WeekendRatio = todouble(WeekendEvents) / TotalEvents\n| extend AnomalyScore = case(\n    LoginAnomaly > 3 or ProcessAnomaly > 3 or FileAnomaly > 3, 90,\n    OffHoursRatio > 0.5 and WeekendRatio > 0.3, 85,\n    LoginAnomaly > 2 or ProcessAnomaly > 2, 75,\n    TimeAnomaly > 2, 70,\n    50\n)\n| where AnomalyScore >= {anomalyThreshold}\n| project user_name, AnomalyScore, LoginAnomaly, ProcessAnomaly, FileAnomaly, \n          OffHoursRatio, WeekendRatio, TotalEvents\n| order by AnomalyScore desc`,\n    parameters: [\n      {\n        name: 'timeRange',\n        type: 'timespan',\n        description: 'Recent time window to analyze',\n        defaultValue: '24h',\n        required: true\n      },\n      {\n        name: 'baselineWindow',\n        type: 'timespan',\n        description: 'Historical baseline window',\n        defaultValue: '7d',\n        required: true\n      },\n      {\n        name: 'anomalyThreshold',\n        type: 'number',\n        description: 'Minimum anomaly score to alert on',\n        defaultValue: 70,\n        required: true\n      }\n    ],\n    tags: ['behavioral-analysis', 'user-monitoring', 'anomaly-detection'],\n    mitreTactics: ['Initial Access', 'Persistence'],\n    mitreAttackIds: ['T1078', 'T1133'],\n    difficulty: 'advanced',\n    useCase: 'Detect compromised user accounts through behavioral analysis'\n  }\n];\n\nexport class SecurityTemplateProvider {\n  private templates: SecurityTemplate[];\n\n  constructor() {\n    this.templates = SECURITY_TEMPLATES;\n  }\n\n  getTemplates(): SecurityTemplate[] {\n    return this.templates;\n  }\n\n  getTemplatesByCategory(category: SecurityCategory): SecurityTemplate[] {\n    return this.templates.filter(t => t.category === category);\n  }\n\n  getTemplatesByTag(tag: string): SecurityTemplate[] {\n    return this.templates.filter(t => t.tags.includes(tag));\n  }\n\n  getTemplatesByDifficulty(difficulty: 'beginner' | 'intermediate' | 'advanced'): SecurityTemplate[] {\n    return this.templates.filter(t => t.difficulty === difficulty);\n  }\n\n  getTemplate(id: string): SecurityTemplate | undefined {\n    return this.templates.find(t => t.id === id);\n  }\n\n  renderTemplate(templateId: string, parameters: Record<string, any>): string {\n    const template = this.getTemplate(templateId);\n    if (!template) {\n      throw new Error(`Template not found: ${templateId}`);\n    }\n\n    let query = template.query;\n    \n    // Replace parameters\n    for (const [key, value] of Object.entries(parameters)) {\n      const placeholder = `{${key}}`;\n      query = query.replace(new RegExp(placeholder.replace(/[{}]/g, '\\\\\\\\$&'), 'g'), String(value));\n    }\n\n    return query;\n  }\n\n  getCategories(): SecurityCategory[] {\n    return Object.values(SecurityCategory);\n  }\n\n  searchTemplates(searchTerm: string): SecurityTemplate[] {\n    const term = searchTerm.toLowerCase();\n    return this.templates.filter(t => \n      t.name.toLowerCase().includes(term) ||\n      t.description.toLowerCase().includes(term) ||\n      t.tags.some(tag => tag.toLowerCase().includes(term)) ||\n      t.useCase.toLowerCase().includes(term)\n    );\n  }\n}","import { KQLLexer } from '../lexer/lexer';\nimport { KQLParser } from '../parser/parser';\nimport { SQLGenerator } from '../execution/sql-generator';\nimport { Query } from '../parser/ast';\n\nexport function validateKQLSyntax(kqlQuery: string): { valid: boolean; errors: string[] } {\n  try {\n    const lexer = new KQLLexer(kqlQuery);\n    const { tokens, errors: lexErrors } = lexer.tokenize();\n\n    if (lexErrors.length > 0) {\n      return {\n        valid: false,\n        errors: lexErrors.map(e => e.message)\n      };\n    }\n\n    const parser = new KQLParser(tokens);\n    const { query, errors: parseErrors } = parser.parse();\n\n    if (parseErrors.length > 0 || !query) {\n      return {\n        valid: false,\n        errors: parseErrors.map(e => e.message)\n      };\n    }\n\n    return { valid: true, errors: [] };\n  } catch (error) {\n    return {\n      valid: false,\n      errors: [error instanceof Error ? error.message : 'Unknown validation error']\n    };\n  }\n}\n\nexport function parseKQLToSQL(kqlQuery: string, organizationId: string): { sql: string; parameters: any[]; errors: string[] } {\n  try {\n    const lexer = new KQLLexer(kqlQuery);\n    const { tokens, errors: lexErrors } = lexer.tokenize();\n\n    if (lexErrors.length > 0) {\n      return {\n        sql: '',\n        parameters: [],\n        errors: lexErrors.map(e => e.message)\n      };\n    }\n\n    const parser = new KQLParser(tokens);\n    const { query, errors: parseErrors } = parser.parse();\n\n    if (parseErrors.length > 0 || !query) {\n      return {\n        sql: '',\n        parameters: [],\n        errors: parseErrors.map(e => e.message)\n      };\n    }\n\n    const sqlGenerator = new SQLGenerator(organizationId);\n    const { sql, parameters } = sqlGenerator.generateSQL(query);\n\n    return { sql, parameters, errors: [] };\n  } catch (error) {\n    return {\n      sql: '',\n      parameters: [],\n      errors: [error instanceof Error ? error.message : 'Unknown error']\n    };\n  }\n}\n\nexport function formatKQLQuery(kqlQuery: string): string {\n  try {\n    const lexer = new KQLLexer(kqlQuery);\n    const { tokens, errors } = lexer.tokenize();\n\n    if (errors.length > 0) {\n      return kqlQuery; // Return original if there are lexical errors\n    }\n\n    const parser = new KQLParser(tokens);\n    const { query, errors: parseErrors } = parser.parse();\n\n    if (parseErrors.length > 0 || !query) {\n      return kqlQuery; // Return original if there are parse errors\n    }\n\n    return formatQuery(query);\n  } catch (error) {\n    return kqlQuery; // Return original on any error\n  }\n}\n\nfunction formatQuery(query: Query, indentLevel: number = 0): string {\n  const indent = '  '.repeat(indentLevel);\n  let formatted = '';\n\n  // Format table expression\n  formatted += query.tableExpression.name;\n  if (query.tableExpression.alias) {\n    formatted += ` as ${query.tableExpression.alias}`;\n  }\n\n  // Format operations\n  for (const operation of query.operations) {\n    formatted += '\\n' + indent + '| ' + formatOperation(operation, indentLevel + 1);\n  }\n\n  return formatted;\n}\n\nfunction formatOperation(operation: any, indentLevel: number): string {\n  const indent = '  '.repeat(indentLevel);\n\n  switch (operation.type) {\n    case 'WhereOperation':\n      return `where ${formatExpression(operation.predicate)}`;\n    \n    case 'ProjectOperation':\n      const columns = operation.columns.map((col: any) => {\n        let result = formatExpression(col.expression);\n        if (col.alias) {\n          result += ` as ${col.alias}`;\n        }\n        return result;\n      }).join(',\\n' + indent + '    ');\n      \n      return operation.columns.length > 3 \n        ? `project\\n${indent}    ${columns}`\n        : `project ${columns.replace(/\\n\\s+/g, ' ')}`;\n    \n    case 'ExtendOperation':\n      const assignments = operation.assignments.map((assignment: any) => \n        `${assignment.name} = ${formatExpression(assignment.expression)}`\n      ).join(',\\n' + indent + '    ');\n      \n      return operation.assignments.length > 2\n        ? `extend\\n${indent}    ${assignments}`\n        : `extend ${assignments.replace(/\\n\\s+/g, ' ')}`;\n    \n    case 'SummarizeOperation':\n      const aggregations = operation.aggregations.map((agg: any) => {\n        let result = agg.function;\n        if (agg.expression) {\n          result += `(${formatExpression(agg.expression)})`;\n        } else {\n          result += '()';\n        }\n        if (agg.alias) {\n          result += ` as ${agg.alias}`;\n        }\n        return result;\n      }).join(', ');\n      \n      let summarizeResult = `summarize ${aggregations}`;\n      if (operation.by && operation.by.length > 0) {\n        const byColumns = operation.by.map((expr: any) => formatExpression(expr)).join(', ');\n        summarizeResult += ` by ${byColumns}`;\n      }\n      \n      return summarizeResult;\n    \n    case 'OrderOperation':\n      const orderBy = operation.orderBy.map((orderExpr: any) => \n        `${formatExpression(orderExpr.expression)} ${orderExpr.direction}`\n      ).join(', ');\n      \n      return `order by ${orderBy}`;\n    \n    case 'TopOperation':\n      let topResult = `top ${formatExpression(operation.count)}`;\n      if (operation.by && operation.by.length > 0) {\n        const byColumns = operation.by.map((orderExpr: any) => \n          `${formatExpression(orderExpr.expression)} ${orderExpr.direction}`\n        ).join(', ');\n        topResult += ` by ${byColumns}`;\n      }\n      return topResult;\n    \n    case 'LimitOperation':\n      return `limit ${formatExpression(operation.count)}`;\n    \n    case 'DistinctOperation':\n      if (operation.columns && operation.columns.length > 0) {\n        const distinctColumns = operation.columns.map((col: any) => formatExpression(col)).join(', ');\n        return `distinct ${distinctColumns}`;\n      }\n      return 'distinct';\n    \n    default:\n      return operation.type.replace('Operation', '').toLowerCase();\n  }\n}\n\nfunction formatExpression(expression: any): string {\n  if (!expression) return '';\n\n  switch (expression.type) {\n    case 'BinaryExpression':\n      const left = formatExpression(expression.left);\n      const right = formatExpression(expression.right);\n      \n      // Add parentheses for complex expressions\n      if (needsParentheses(expression)) {\n        return `(${left} ${expression.operator} ${right})`;\n      }\n      return `${left} ${expression.operator} ${right}`;\n    \n    case 'UnaryExpression':\n      const operand = formatExpression(expression.operand);\n      return `${expression.operator}${operand}`;\n    \n    case 'CallExpression':\n      const args = expression.arguments.map((arg: any) => formatExpression(arg)).join(', ');\n      return `${expression.function}(${args})`;\n    \n    case 'MemberExpression':\n      const object = formatExpression(expression.object);\n      const property = formatExpression(expression.property);\n      \n      if (expression.computed) {\n        return `${object}[${property}]`;\n      }\n      return `${object}.${property}`;\n    \n    case 'Identifier':\n      return expression.quoted ? `\\`${expression.name}\\`` : expression.name;\n    \n    case 'Literal':\n      if (expression.dataType === 'string') {\n        return `\"${expression.value}\"`;\n      }\n      return String(expression.value);\n    \n    default:\n      return '';\n  }\n}\n\nfunction needsParentheses(expression: any): boolean {\n  // Add logic to determine when parentheses are needed\n  // This is a simplified version - a full implementation would consider operator precedence\n  return expression.operator === 'and' || expression.operator === 'or';\n}\n\nexport function extractTableNames(kqlQuery: string): string[] {\n  try {\n    const lexer = new KQLLexer(kqlQuery);\n    const { tokens, errors } = lexer.tokenize();\n\n    if (errors.length > 0) {\n      return [];\n    }\n\n    const parser = new KQLParser(tokens);\n    const { query, errors: parseErrors } = parser.parse();\n\n    if (parseErrors.length > 0 || !query) {\n      return [];\n    }\n\n    const tableNames: string[] = [query.tableExpression.name];\n\n    // Extract table names from join operations\n    for (const operation of query.operations) {\n      if (operation.type === 'JoinOperation') {\n        tableNames.push(operation.table.name);\n      } else if (operation.type === 'UnionOperation') {\n        tableNames.push(...operation.tables.map((table: any) => table.name));\n      }\n    }\n\n    return [...new Set(tableNames)]; // Remove duplicates\n  } catch (error) {\n    return [];\n  }\n}\n\nexport function extractColumnNames(kqlQuery: string): string[] {\n  try {\n    const lexer = new KQLLexer(kqlQuery);\n    const { tokens, errors } = lexer.tokenize();\n\n    if (errors.length > 0) {\n      return [];\n    }\n\n    const parser = new KQLParser(tokens);\n    const { query, errors: parseErrors } = parser.parse();\n\n    if (parseErrors.length > 0 || !query) {\n      return [];\n    }\n\n    const columnNames = new Set<string>();\n\n    // Extract columns from operations\n    for (const operation of query.operations) {\n      extractColumnsFromOperation(operation, columnNames);\n    }\n\n    return Array.from(columnNames);\n  } catch (error) {\n    return [];\n  }\n}\n\nfunction extractColumnsFromOperation(operation: any, columnNames: Set<string>): void {\n  switch (operation.type) {\n    case 'WhereOperation':\n      extractColumnsFromExpression(operation.predicate, columnNames);\n      break;\n    \n    case 'ProjectOperation':\n      operation.columns.forEach((col: any) => {\n        extractColumnsFromExpression(col.expression, columnNames);\n      });\n      break;\n    \n    case 'ExtendOperation':\n      operation.assignments.forEach((assignment: any) => {\n        extractColumnsFromExpression(assignment.expression, columnNames);\n      });\n      break;\n    \n    case 'SummarizeOperation':\n      operation.aggregations.forEach((agg: any) => {\n        if (agg.expression) {\n          extractColumnsFromExpression(agg.expression, columnNames);\n        }\n      });\n      if (operation.by) {\n        operation.by.forEach((expr: any) => {\n          extractColumnsFromExpression(expr, columnNames);\n        });\n      }\n      break;\n    \n    case 'OrderOperation':\n      operation.orderBy.forEach((orderExpr: any) => {\n        extractColumnsFromExpression(orderExpr.expression, columnNames);\n      });\n      break;\n  }\n}\n\nfunction extractColumnsFromExpression(expression: any, columnNames: Set<string>): void {\n  if (!expression) return;\n\n  switch (expression.type) {\n    case 'Identifier':\n      columnNames.add(expression.name);\n      break;\n    \n    case 'BinaryExpression':\n      extractColumnsFromExpression(expression.left, columnNames);\n      extractColumnsFromExpression(expression.right, columnNames);\n      break;\n    \n    case 'UnaryExpression':\n      extractColumnsFromExpression(expression.operand, columnNames);\n      break;\n    \n    case 'CallExpression':\n      expression.arguments.forEach((arg: any) => {\n        extractColumnsFromExpression(arg, columnNames);\n      });\n      break;\n    \n    case 'MemberExpression':\n      extractColumnsFromExpression(expression.object, columnNames);\n      if (expression.computed) {\n        extractColumnsFromExpression(expression.property, columnNames);\n      }\n      break;\n  }\n}"],"mappings":"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","names":["TokenType","OptimizationType","CompletionItemKind","CompletionTriggerKind","DiagnosticSeverity","SecurityCategory"]}